前言
  它是对 C 语言的扩充
  主要是引进面向对象机制
  最初的 C++ 被称为"带类的C",1983年正式取名为 C++
  特点:
    1.C++ 是 C 的超集
      C++ 保持与 C 语言的兼容,这使得许多 C 代码不经修改就可以为 C++ 所用
    2.C++ 保持了 C 语言的简洁,高效和接近汇编语言等特点
      并对 C 语言的功能做了不少扩充
      用 C++ 编写的程序比 C 语言更安全,可读性更好,代码结构更为合理
    3.用 C++ 编写的程序质量高
      从开发时间,费用到形成的软件的可重用性,可扩充性,可维护性和可靠性等方面都有了很大的提高
    4.增加了面向对象的机制

>> 与 <<
  运算符 >> 在 C++ 中仍然保持 C 语言的"右移"功能
  但用于输入时扩充了其功能,表示将标准输入流对象 cin(通常指键盘) 读取的数值传送给右侧指定的变量
  >> 允许用户输入一连串数据
    cin >> a >> b >> c;
  数据之间用空白符(空格,回车, Tab 键)分隔
  1.默认情况下,运算符 >> 将跳过空白符,读入后面的与其变量类型相对应的值
    当输入字符串时,提取运算符 >> 的作用是跳过空白
    读入非空白字符,直到遇到另一个空白字符为止,并在串尾添加一个字符串结束符'\0'
      char *str;
      cin >> str;
      输入:abc def
      输出:abc
  2.系统除检查是否有空白外,还检查输入数据与变量的匹配情况
      int i;
      float x;
      cin >> i >> x;
      输入:56.79 45.6
      输出:56 0.79
    系统根据变量的类型来分隔输入的数据
    在上述情况下,系统把 56.79 中的小数点前的整数部分赋值给整型变量 i
    而把剩下的 0.79 赋值给浮点型变量 x

cin 与 cout
  使用 cin 和 cout 进行 I/O 操作时,在程序中必须嵌入头文件 iostream
  在 C++ 中我们仍然可以沿用传统的 stdio 函数库中的 I/O 函数,如 scanf 和 printf 等等其它的 C 输入输出函数
  在使用 cin 和 cout 输入输出数据时,会使用系统默认的格式
  我们也可以对输入输出的格式进行控制
    1.stew(n)
      控制输出数据的宽度
      需要添加头文件 iomanip

程序的编辑,编译,连接和运行
  Windows 平台下有 Visual C++ 和 C++ Builder
  Linux 平台下有 gcc 和 gdb

带默认参数的函数
  C 是没有此功能的

函数重载
  在同一作用域内,两个或两个以上的函数共用一个函数名
  被重载的函数称为重载函数
  系统根据实参的个数和类型决定使用哪个函数
  注意:
    1.函数返回值不在参数匹配检查之中
        int add(int a, int b){...};
        double add(int a, int b){...};
    2.函数重载与带默认参数的函数同时使用时,会引起二义性
        int add(int a=0, int b=0){...};
        int add(int a){...};
        add(5);
    3.在函数调用时,如果给出的实参和形参类型不相符
      C++ 编译器会自动执行类型转换工作
      如果转换成功,则程序继续执行,在这种情况下,有可能产生不可识别的错误
        int add(int a, int b){...};
        long add(long a, long b){...};
        add(1.1, 2.2);
      两个函数都满足条件,编译时会报错

::
  作用域运算符
  通常情况下,如果有两个同名变量,一个是全局的,另一个是局部的
  那么局部变量在其作用域下具有较高的优先权,他将屏蔽全局变量
  如果想在局部变量的作用于下使用同名的全局变量
  可在变量前加上 ::

new 和 delete
  C 语言使用函数 malloc 和 free 动态分配内存和释放动态分配的内存
  C++ 使用运算符 new 和 delete 能更好且简单地进行内存的分配和释放
  new 的基本形式:
    指针变量名 = new 类型;
    int *p;
    p = new int;
  delete 的基本形式:
    delete 指针变量名;
    delete p;
  虽然 new 和 delete 完成的功能类似于函数 malloc 和 free
  但它们有以下几个有点:
    1.new 可以根据数据类型自动计算所需要分配内存的大小
      而使用 malloc 函数时必须使用 sizeof 函数计算所需要的字节数,这就减少了发生错误的可能性
    2.new 能够自动返回正确的指针类型,而 malloc 函数的返回值类型一律为 void*
      必须在程序中进行强制类型转换,才能使其指针指向具体的数据
  1.使用 new 为数组动态分配内存空间
    必须提供所有维的大小
      int *pi = new int[10];
      int *pii = new int[2][2];
    无论几维数组,都只需要一对方括号
      delete []指针变量名;
      delete []pi;
      delete []pii;
  2.new 可为简单变量分配内存的同时进行初始化
    指针变量名 = new 类型(初值);
    int *p = new int(1);
  3.使用 new 动态分配内存时,若没有足够的内存满足分配要求
    则动态分配空间失败,部分编译系统将返回空指针 NULL
    因此可以对内存的动态分配是否成功进行检查
      if(!p){
        cout << "allocation failure.\n";
        return 1;
      }
    内存动态分配成功后不宜变动指针的值,否则在释放存储空间时会引起系统内存管理失败
  4.用 new 分配的存储空间不会自动释放,只能通过 delete 释放,
    因此要适时释放动态分配的存储空间

引用
  & 引用声明符
  它是对 C 的一个重要扩充
  变量的"引用"即为变量的别名
    类型 & 引用名 = 已定义的变量名;
    int i = 1;
    int &j = i;
  1.引用不是一种独立的数据类型,在声明引用时必须立即进行初始化
      int i = 1;
      int &j;
      j = i; // 错误,不能声明完成后再赋值
      double &k = i; // 错误,类型不一致
  2.可以为引用再引用
      int i = 1;
      int &j = i;
      int &k = j;
  3.指针是通过地址间接访问变量
    而引用是通过别名直接访问变量
  4.引用在初始化后不可以再被重新声明为另一个变量的引用
      int i,k;
      int &j = i;
      j = &k;
  引用作为函数参数
    1.C++ 提供引用,其主要一个用途时将引用作为函数的参数
      即"传值调用",这种传递是单向的,在执行函数期间形参值发生的变化并不会传回给实参
    2.指针变量作为函数参数
      这时实参传给形参的是实参变量的地址
      即"传址调用",这种传递是双向的,在执行函数期间形参值发生的变化会传回给实参
        void swap(int *a, int *b){...}
        int main(){
          swap(&m, &n);
        }
        m 和 n 的数据会互换
    3.把变量的引用作为函数形参
      即"传址调用"
        void swap(int &a, int &b){...}
        int main(){
          swap(m, n);
        }
        m 和 n 的数据会互换
  注意:
    1.不能建立引用的数组
        int a[4]="asd";
        int &arr[4] = a;
      企图建立一个包含4个元素的引用的数组,错误做法
      数组名 a 只代表数组首元素的地址,本身并不是一个占有存储空间的变量
    2.不能建立引用的引用,不能建立指向引用的指针
        int a = 1;
        int && b = a;
        int &*p = a;
      引用本身不是数据类型,所以没有引用的引用,也没有引用的指针
    3.可以将引用的地址赋值给指针,此时指针指向原来的变量
        int a = 1;
        int &b = a;
        iny *p = &b;
    4.可以用 const 对引用加以限定,不允许改变该引用的值
        int a = 5;
        const int &b = a;
        b = 3; // 错误,不可改变
      有时希望函数中保护形参的值不被改变可用此方法
        // 通过函数 i_Max 求出整型数组 a[200] 中的最大值
        int i_Max(const int* ptr); // 这样做的目的是确保形参数组的数据不被破坏(只读不可写)
        i_Max(a);

类和对象
  1.从结构到类
    C 语言的结构体有一个缺点
    一旦建立了一个结构体变量就可以在结构体外直接访问数据
    但现实中有些数据是不可以随便访问的,这样做是不安全的
    C 语言的结构体无法对数据进行保护和权限控制
    结构体中的数据和对数据进行的操作是分离的,没有把两者作为一个整体进行封装
    因此使程序的复杂性很难控制,维护数据要花费精力,所以影响生产效率
    于是 C++ 引入类的概念
    类将数据和相关函数封装成整体,具有良好的外部接口
    防止数据未经授权被访问,提供了模块间的独立性
    类声明的一般格式:
      class 类名{
        public:
          公有数据成员;
          公有成员函数;
        private:
          私有数据成员;
          私有成员函数;
      };
    关键字
      1.public
      2.private
      3.protected
        保护成员,可由本类的成员函数访问,也可以由本类的派生类的成员函数访问
        类外的任何访问都是违法的
    C++ 默认情况下类中的成员都是私有的
    结构体中的成员都是公有的
  2.成员函数的定义
    成员函数在类外定义的一般形式:
      返回值类型 类名::成员函数名(参数表){
        函数体
      }
      class Date{
        public:
          void setDate(int y, int m, int d); // 函数原型
          void showDate();
        private:
          int year;
          int month;
          int day;
      };
      void Date::setDate(){
        year = y;
        month = m;
        day = d;
      }
      void Date::showDate(){
        cout << year << "." << month << "." << day << endl;
      }
    在类声明中,成员函数原型的参数表中可以不说明参数名字而只用说明它们的类型
      void setDate(int , int , int);
    采用"在类声明中只给出成员函数的原型,而将成员函数的定义放在类的外部"的定义方式是 C++ 程序设计良好习惯
    这种方式不仅可以减少类体的长度,使类的声明简洁明了,便于阅读
    而且有助于把类的接口和类的实现细节相分离,隐藏了执行的细节
  3.内联成员函数的定义
    a.隐式声明
      将成员函数直接定义在类的内部,此时函数就是隐含的内联成员函数
      内联函数的调用类似宏指令的扩展,它直接在调用处扩展其代码,而不进行一般函数的调用操作
      这种定义内联成员函数的方法没有使用关键字 inline 进行声明,因此此方法称为隐式定义
        class Date{
          public:
            void setDate(int y, int m, int d){ // 直接定义在类的内部
              year = y;
              month = m;
              day = d;
            }
            void Date::showDate(){ // 直接定义在类的内部
              cout << year << "." << month << "." << day << endl;
            }
          private:
            int year;
            int month;
            int day;
        };
    b.显式声明
      在类中只给出成员函数的原型,而将成员函数的定义放在类的外部
      但需要在(类内函数原型声明前和)类外定义成员函数前需要冠以关键字 inline
      以此显式地说明这是一个内联函数,此方法称为显式定义
        class Date{
          public:
            inline void setDate(int y, int m, int d); // 函数原型声明前也可不加 inline
            inline void showDate();
          private:
            int year;
            int month;
            int day;
        };
        inline void Date::setDate(int y, int m, int d){
          year = y;
          month = m;
          day = d;
        }
        inline void Date::showDate(){
          cout << year << "." << month << "." << day << endl;
        }
      使用 inline 定义内联函数时
      必须将类的声明和内联成员函数的定义都放在同一文件(或同一个头文件)中
      否则编译时无法进行代码置换

对象的定义和使用
  C++ 把类的变量称为类的对象
  对象也称为类的实例
  对象的定义:
    1.声明类的同时直接定义了对象
      class Date{
        ...
      }date1,date2,*p;
      p = &date1;
    2.声明类之后再定义对象
      Date date3,date4;
  对象中成员的访问:
    1.通过对象名和对象选择符访问对象中的成员
        date1.setDate(2021,1,22);
        date1.showDate();
      "."称为对象选择符,简称点运算符
    2.通过指向对象的指针访问对象中的成员
        date1.year;
        (*p).year;
        p->year;
    3.通过对象的引用访问对象中的成员
      为对象定义一个引用(为对象起别名)
      对象与引用占有相同的存储单元
        Date &d1 = date1;
        d1.year;

构造函数
  构造函数是一种特殊的成员函数
  它主要用于为对象分配空间进行初始化
  构造函数的名字必须与类名相同
  可以有任意类型的参数
  没有任何返回类型,不返回任何值
  不需要用户调用,而是在建立对象时自动执行的
  构造函数的功能是由用户定义的,用户根据对象初始化的要求设计函数体和函数参数
    class Date{
      public:
        Date(int y, int m, int d); // 构造函数原型声明
        void showDate();
      private:
        int year;
        int month;
        int day;
    };
    Date::Date(int y, int m, int d){
      year = y;
      month = m;
      day = d;
    }
    void Date::showDate(){
      cout << year << "." << month << "." << day << endl;
    }
  构造函数的主要功能是给对象分配空间,进行初始化

用成员初始化表对数据成员初始化
  C++ 还提供了另一种初始化数据成员的方法
  用成员初始化来表现对数据成员的初始化
  在函数首部实现对数据成员的初始化
    Date::Date(int y, int m, int d):year(y), month(m), day(d){}
  建议使用此方法
        
析构函数
  一种特殊的成员函数
  它执行与构造函数相反的操作
  通常用于撤销对象时的清理任务,如释放分配给对象的内存空间等
  特点:
    1.析构函数与构造函数名字相同,但需要在前加一个波浪符号 ~
    2.析构函数没有参数和返回值,不能重载
    3.当撤销对象时,编译系统会自动地调用析构函数
  class Date{
    public:
    ~Date();
    ...
  };
  ~Date::Date(){}
  ...

默认的构造函数和默认的析构函数
  如果没有给类定义构造函数
  系统会自动生成一个默认的无参构造函数和一个无参析构函数
  如果有定义则系统不会这样做

构造函数的重载
  一个类可定义多个构造函数,即重载
  注意不要忘了函数原型声明

拷贝构造函数
  一种特殊的构造函数,其形参是本类对象的引用
  其作用是在建立一个新对象时,使用一个已经存在的对象去初始化这个对象
  特点:
    1.本质为构造函数,所以函数名与类名相同,且没有返回值
    2.拷贝函数只有一个参数,并且是同类对象的引用
    3.每个类必须有一个拷贝构造函数,也可以自己定义
      如果没有定义则系统会自动产生一个默认的拷贝构造函数
    class Date{
      public:
      Date(const Date& d){
        year = d.year++;
        month = d.month++;
        day = d.day++;
      }
      ...
    };
    int main(){
      Date date1;
      ... // 初始化 date1
      Date date2(date1); // 拷贝,也称代入法
      Date date3 = date1; // 赋值法
    }
  赋值法实际调用的也是拷贝构造函数
  调用拷贝函数的3种情况
    1.用类的对象去初始化该类的另一个对象时
    2.当函数的形参是类的对象时
    3.当函数的返回值是对象时
      当函数调用 return xxx; 时将会调用拷贝函数
      将 xxx 的值拷贝到一个无名对象中,这个无名对象是编译系统在主程序中临时创建的
      函数运行结束时对象 xxx 消失,但临时对象会保存至调用该函数处的变量中(class xx = fun();)
      执行完该语句后,临时无名对象的使命也就完成了,该临时对象便自动消失了

自引用指针
  C++ 为成员函数提供了一个名为 this 的指针,即称为自引用指针
  每当创建一个对象时,系统就把 this 指针初始化为指向该对象
  即 this 指针的值是当前调用成员函数的对象的起始地址
  每当调用成员函数时,系统就自动把 this 指针作为一个隐含的参数传递给该函数

string 类
  强调一下,它是一个类!
  C++ 支持两种类型的字符串
  第一种是 C 语言中介绍过的包含一个结束符"\0"(即以 NULL 结束)的字符数组
  标准库函数提供了一组对其进行操作的函数,可完成许多常用的字符操作
  例如 strcpy strcat strlen 等等
  但数据与处理数据的函数分离不符合面向对象方法的要求
  为此,在 C++ 的标准库中声明了另一种更方便的字符串类型,即字符串类 string
  使用 string 类必须在程序的开始包括头文件 string
    #include<string>
  常用的 string 类运算符
    运算符   注释
    =        赋值
    +        将两个字符串连接成一个新字符串
    +=       <略>
    ==       判断两字符串是否相等
    !=       <略>
    <        <略>
    <=       <略>
    >=       <略>
    []       s[1]; 访问字符串下标为1的字符
    >>       cin>>s; 从键盘输入一个字符串给 s
    <<       cout<<s; 将字符串 s 输出
  
对象数组
  指每一个数组元素都是对象的数组
    class Exam{
      public:
      Exam(){
        x = 100;
      }
      Exam(int n){
        x = n;
      }
      int get_x(){
        return x;
      }
      private:
        int x;
    };
    int main(){
      Exam arr[5] = {1, 2, 3, 4} // 用只有一个参数的构造函数给对象数组赋值,最后一个使用无参构造函数初始化
      for(int i=0;i<4;i++){
        cout << arr[i].get_x() << endl;
      }
    }

对象指针
  每个对象在初始化后都会在内存中占有一定的空间
  因此,既可以通过对象名访问
  也可以通过对象地址访问
    Exam e1,e2[2],*p;
    p = &e1;
    p->get_x();
    p = &e2;
    p++;
    p->get_x(); // 访问 e2[1]

使用对象作为函数参数
  <略>

使用对象指针作为函数参数
  <略>

使用对象引用作为函数参数
  在实际应用中,大部分程序员喜欢用对象引用取代对象指针作为函数参数
    
静态数据成员
  有时希望某个或几个数据成员为所有的对象共有,实现一个类的多个对象之间的数据共享
  于是 C++ 提出了静态成员的概念
    static 数据类型 数据成员名;
    class xxx{
      public:
      static int i;
      ...
    };
    int main(){
      xxx::i = 100; // 公共静态数据成员可在对象定义前被访问
    }
  注意:
    1.静态数据成员属于类(准确地说是属于类中对象的集合),它不属于某一个对象
      因此可以使用"类名::"访问静态的数据成员
        类名::静态数据成员名
    2.静态数据成员与静态变量一样,是在编译时创建并初始化的,它在任何对象被建立之前就存在
        对象名.静态数据成员名;
        对象指针->静态数据成员名;
    3.在类外,私有静态数据成员不能直接访问,必须通过公有的成员函数访问
    6.C++ 支持静态数据成员的一个主要原因是可以不必使用全局变量
      依赖全局变量的类几乎都是违反面向对象程序设计的封装特性的
    7.与普通数据成员不同,静态数据成员不可以在定义时进行赋值,应该在类外单独进行

静态成员函数
  静态成员函数属于整个类,是该类所有对象共享的成员函数
  它的作用是为了处理静态数据成员
    static 返回类型 静态成员函数名(参数表);
  调用公有静态成员函数的一般格式:
    类名::静态成员函数名(实参表);
    对象.静态成员函数名(实参表);
    对象指针->静态成员函数名(实参表);
  一般而言,静态成员函数不访问类中的非静态成员
  若有需要,静态成员函数只能通过对象名(或指针,对象引用)访问该对象的非静态成员

友元
  类的主要特点之一是数据隐藏和封装
  但是,有时为了访问类的私有成员而需要在程序中多次调用成员函数
  频繁调用带来较大的时间和空间开销,从而降低程序的运行效率
  为此 C++ 提供了一种访问私有成员的途径
  在不放弃私有成员数据安全性的情况下
  使得一个普通函数或类的成员函数可以访问到封装于某一类中的信息(包括公有,私有,保护成员)
  在 C++ 中用友元作为实现这个要求的辅助手段
  C++ 中的友元为数据隐藏这堵墙开了一个孔
  外界可以通过这个孔窥视类内部的秘密
  友元是一扇通向私有成员的后门

友元函数
  友元函数既可以是不属于任何类的非成员函数,也可以是另一个类的成员函数
  友元函数不是当前类的成员函数,但它可以访问该类所有的成员
  包括私有成员,保护成员和公有成员
  在类中声明友元函数时需要在其函数名前加关键字 friend
  友元函数既可定义在类内部,也可定义在类的外部
  将非成员函数声明为友元函数
    注意:
      1.友元函数不是类的成员,外部定义时不需要加"类名::",所以不能使用 this
      2.引入友元提高了程序运行效率,实现了类之间的数据共享,也方便编程
        但声明友元函数相当于在实现封装的黑盒子上开洞
        这将破坏数据的隐蔽性和类的封装性,降低了程序的可维护性
        这与面向对象的程序设计思想是背道而驰的,慎用友元函数
  将成员函数声明为友元函数
    一个类的成员函数也可以作为另一个类的友元函数
    它是友元函数的一种,称为友元成员函数
    友元成员函数既可以访问自己所在类对象中的私有成员和公有成员
    也可以访问 friend 声明语句所在类对象中的所有成员
    这样能使两个类相互合作,协调工作,完成某一项任务

友元类
  将一个类 A 声明为另一个类 B 的友元
  这时类 A 为类 B 的友元类
  类 B 的所有成员函数都成为类 B 的友元函数
  类 B 中的所有成员函数都可以访问类 A 中的所有成员
    friend 类名;
  注意:
    1.友元关系是单向的,不具有交换性
      若声明了类 X 是类 Y 的友元(即在类 Y 定义中声明类 X 为 friend 类)
      不等于类 Y 一定是 X 的友元,这要看类 X 中是否具有相应的声明
    2.友元关系不具有传递性
      若类 X 是类 Y 的友元,类 Y 是类 Z 的友元
      不一定类 X 是类 Z 的友元
      如果想让类 X 是类 Z 的友元类,应在类 Z 中作出声明

类的组合
  在一个类中内嵌另一个类的对象作为数据成员,称为类的组合
  该内嵌对象称为对象成员,也称为子对象
    class Y{ ... };
    class X{
      Y y;
      ...
    };
  在创建对象时既要本类的基本数据成员初始化,又要对内嵌的对象成员进行初始化
    class X{
      类名1 对象成员名1;
      ...
      类名i 对象成员名i;
    };
  一般定义:
    X::X(形参列表0):(对象成员名1)(形参表1),...,对象成员名i(形参表i){
      // 类 X 的构造函数体
    }
  形参表i给出了初始化对象成员所需要的数据,它们一般来自形参表0

共享数据的保护
  虽然 C++ 采取了不少措施(如设置 private 数据等)来增加数据的安全性
  但是有些数据是共享的,人们可以在不同场合通过不同的途径访问同一个数据对象
  程序中各种形式的数据共享在不同程度上破坏了数据的安全性
  常类型的引入就是为了既保证数据共享又防止数据被改动
  常类型是指使用类型修饰符 const 说明的类型
  常类型的变量或对象成员的值在程序运行期间是不可改变的

常对象
  用 const 修饰的对象被称为常对象
  常对象中的数据成员为常量且必须要有初值
  常对象在整个生存期内不能被改变
  一般形式:
    类名 const 对象名[(参数表)];
    const 类名 对象名[(参数表)];
  在定义时必须进行初始化且不能被更新
  另外,常对象只能调用常成员函数

常对象成员
  C++ 可以声明类时将其中的成员声明为 const
  即声明为常数据成员和常成员函数
  常数据成员
    const 类型 变量名;
  常成员函数
    类型 函数名(参数表) const;

多文件程序
  从众多的完整 c++ 源程序实例中分析得出
  基本都是由3部分构成
    类的声明部分
    类的实现部分
    类的使用部分
  在实际程序设计中,一个源程序按照结构可以划分为3个文件
    类声明文件(*.h)
    类实现文件(*.cpp)
    类的使用文件(*.cpp,主函数文件)
  将类的声明部分放在类声明文件(头文件)中,类中向用户提供成员函数所需的函数原型,这就形成了类的 public 外部接口
  将类成员函数的定义放在类实现文件中,这就形成了类的实现方法
  将类的使用部分(通常是主程序)放在类使用文件中,这样可以清晰地表示出本程序所要完成的工作
  把类的声明和实现放在两个不同的文件中主要有以下考虑:
    1.类的实现文件通常较大,将两者混合在一起不便阅读,管理和维护
    2.将类的成员函数的实现放在其声明文件中与放在实现文件中在编译时的含义是不一样的
      若将成员函数的实现直接放在类的声明中,则类的成员函数将作为内联函数处理
      显然这是不合适的
    3.对于软件开发商来说,他们可以向用户提供一些程序模块这些程序模块往往只向用户公开类的声明(即接口)而不是源码
      类的用户使用类时不需要访问类的源代码,但需要连接类的目标码
      类的声明和实现分开管理可以很好地解决这个问题
    4.便于团体式的大型软件开发

继承
  继承即从先辈处得到属性和行为特征

派生
  从已有类(基类或父类)产生新类(子类或派生类)的过程即为类的派生
  一般声明格式:
    class 派生类名:[继承方式] 基类名{
      派生类新增的数据成员和成员函数
    }
  继承方式:
    1.公有继承
    2.私有继承
    3.保护继承
  如果不显式地给出继承方式关键字,系统默认为私有继承

基类成员在派生类中的访问属性
  基类中的成员   继承方式   基类成员在派生类中的访问属性
  private       private    不可直接访问
  protected     private    private
  public        private    private

  private       protected  不可直接访问
  protected     protected  protected
  public        protected  protected

  private       public     不可直接访问
  protected     public     protected
  public        public     public

派生类对基类成员的访问规则
  1.私有继承的访问规则
    基类中的成员   私有成员   保护成员   公有成员
    内部访问       不可访问   可访问     可访问
    对象访问       不可访问   不可访问   不可访问
  2.保护继承的访问规则
    基类中的成员   私有成员   保护成员   公有成员
    内部访问       不可访问   可访问     可访问
    对象访问       不可访问   不可访问   不可访问
  3.公有继承的访问规则
    基类中的成员   私有成员   保护成员   公有成员
    内部访问       不可访问   可访问     可访问
    对象访问       不可访问   不可访问   可访问

派生类构造函数和析构函数的调用顺序
  通常情况下,当创建派生类对象时
  首先调用基类的构造函数
  随后再调用派生类的构造函数
  当撤销派生类对象时,则先调用派生类的析构函数
  随后再调用基类的析构函数

派生类构造函数和析构函数的构造规则
  1.简单的派生类的构造函数和析构函数
    当基类的构造函数没有参数或没有显式定义构造函数时
    派生类可以不向基类传递参数,甚至可以不定义构造函数
    派生类构造函数的一般格式:
      派生类名(参数总表):基类名(参数表){
        派生类新增数据成员的初始化语句
      }
    析构函数各自定义即可
  2.含有子对象的派生类的构造函数
    一般格式:
      派生类名(参数总表):基类名(参数表0),子对象名1(参数表1),...,子对象名n(参数表n){
        派生类新增成员的初始化语句
      }
    在定义派生类对象时,构造函数的调用顺序如下:
      1.调用基类的构造函数,对基类数据成员初始化
      2.调用子类对象的构造函数,对子对象的数据成员初始化
      3.调用派生类的构造函数体,对派生类数据成员初始化
      4.撤销对象时,析构函数的调用顺序与构造函数的调用顺序正好相反
        首先调用派生类的析构函数,然后调用子对象的析构函数,最后调用基类的析构函数
    注意:
      1.当基类构造函数不带参数时,派生类不一定需要定义构造函数
      2.若基类使用默认构造函数或不带参数的构造函数,则在派生类中定义构造函数时可略去":基类名(参数表)"
        此时若派生类也不需要构造函数则可不定义构造函数
      3.如果派生类的基类也是一个派生类,每个派生类只需负责其直接基类或基类数据成员的初始化,依次上溯

在派生类中显示访问基类成员
  C++ 允许派生类重新说明与基类成员同名的成员,称派生类成员覆盖基类的同名成员
  一般形式:
    基类名::成员名
    或
    基类名::成员函数(参数表);

多重继承
  当一个派生类具有多个基类时,这种派生方法称为多基派生或多重继承
  假设已声明类 X 和 Y ,可声明多重继承的派生类 Z
    class Z:public X,private Y{
      派生类 Z 中新增的数据成员和成员函数;
    };
  声明多重继承派生类的一般形式:
    class 派生类名:继承方式1 基类名1, ... , 继承方式i 基类名i, ... , 继承方式n 基类名n{
      派生类新增的数据成员和成员函数
    };

多重继承派生类的构造函数与析构函数
  其与单继承时的构造函数定义形式相似,只是在初始表中包含多个基类构造函数,它们之间用","分隔
  一般形式:
    派生类名(参数总表):基类名1(参数表1), ... ,基类名i(参数表i),...,基类名n(参数表n){
      派生类新增成员的初始化语句
    }
  *执行 12 观察析构函数执行顺序!

虚基类
  如果一个类有多个基类
  而这些直接基类又有一个共同的基类
  则在最底层的派生类中会保留这个间接的共同基类数据成员的多份同名成员
  在派生类中访问这些同名的成员时必须加上"基类名::"
  使其唯一地标识是哪一个基类的成员,以免产生二义性
  声明虚基类的语法形式:
    class 派生类名:virtual 继承方式 类名{
      ...
    }
  *通俗概括
      Base3
      ^   ^
  Base1   Base2
     ^     ^
      Base(A)
   不声明虚基类: Base1 和 Base2 除了包含 Base 中的 a 之外还会各自另保存一个 a 数据成员
               即 Base1 和 Base2 各自都有2个 a 且互不影响,那么对于 Base3 来说就共有3个同名为 a 的数据成员
   声明虚基类: Base1 和 Base2 共用 Base 中 a 数据成员,只有一个名为 a 的数据成员

虚基类的初始化
  在使用虚基类机制时应该注意以下几点:
    1.如果在虚基类中定义有带形参的构造函数,并且没有定义默认形式的构造函数
      则在整个继承结构中,所有直接或间接的派生类都必须在构造函数的成员初始化表中列出对虚基类构造函数的调用
      以初始化在虚基类中定义的数据成员
    2.建立一个对象时,如果这个对象中含有从虚基类继承来的成员
      则虚基类的成员是由最远派生类的构造函数通过调用虚基类的构造函数进行初始化的
      该派生类的其它基类对虚基类构造函数的调用都自动被忽略
    3.若同一层次中同时包含虚基类和非虚基类
      应先调用虚基类的构造函数,再调用非虚基类的构造函数
    4.对于多个虚基类,构造函数的执行顺序仍然是先左后右,自上而下
    5.对于非虚基类,构造函数的执行顺序仍是先左后右,自上而下
    6.若虚基类由非虚基类派生而来,则仍然先调用基类构造函数,再调用派生类的构造函数 

多态性
  多态机制不仅增加了面向对象软件系统的灵活性,进一步减少了冗余信息
  而且显著提高了软件的可重用性和可扩展性
  多态性的应用可以使编程显得更为简捷,便利
  它是程序的模块化设计提供了又一手段
  概述:
    多态性指向不同的对象发送同一个信息
    不同的对象在接收时会产生不同的行为(即方法)
    在 C++ 中,编译时多态性主要是通过函数重载和运算符重载实现的
    运行时多态性主要是通过虚函数实现
  例:
    class Base{...};
    class Derived:public Base{...};
  根据复制兼容规则,在基类 Base 的对象可以使用的任何地方
  都可以用派生类 Derived 的对象来替代,但只能使用从基类继承来的成员
    1.派生类对象可以向基类对象赋值
      即用派生类对象中从基类继承来的数据成员
      逐个赋值给基类对象的数据成员
        Base b;
        Derived d;
        d=b;
    2.派生类对象可以初始化基类对象的引用
        Derived d;
        Base &br=d;
    3.派生类对象的地址可以赋值给指向基类对象的指针
        Derived d;
        Base *p=&d;
    4.若函数的形参是基类对象或基类对象的引用
      在调用函数时可以用派生类对象作为实参
        class Base{
          public:
          int i;
          ...
        }
        class Derived:public Base{
          public:
          fun(Base b){
            cout << b.i << endl;
          }
          ...
        }
        int main(){
          Derived d1,d2;
          d1.fun(d2);
        }
  注意:
    1.声明为指向基类对象的指针可以指向它的公有派生的对象,且只能访问派生类中从基类继承来的成员
      但不允许指向它的私有派生的对象
    2.允许将一个声明为指向基类的指针指向其公有派生类的对象
      但是不能将一个声明为指向派生类对象的指针指向其基类的对象
    3.

虚函数
  虚函数是重载的另一种表现形式
  它是一种动态的重载方式,它提供了一种更为灵活的运行时的多态性机制
  虚函数允许函数调用与函数体之间的联系在运行时才建立,在运行时才决定如何运作
  即动态联编

虚函数的引入
  由上文可知:
    基类的对象指针可以指向它的公有派生类的对象
    但是当其指向公有派生类对象时,它只能访问派生类中从基类继承来的成员
    而不能访问公有派生类中定义的成员
  由 15.cpp 可知
  虽然指针 pb 指向了派生类对象 b2
  但是执行语句 pb->show() 调用的不是派生类的成员函数 show
  而仍然是基类的同名成员函数 show
  这显然不是我们所期望的
  使用对象指针的目的是为了表达一种动态的性质
  即当指针指向不同的对象(基类对象或派生类对象)时
  分别调用不同类的成员函数
  如果将函数说明为虚函数,就能实现这种动态调用的功能

虚函数的作用
  使用对象指针的目的就是为了表达一种动态的性质
  即当指针指向不同的对象(基类对象或派生类对象)时分别调用不同类的成员函数
  定义虚函数:
    virtual 返回类型 函数名(形参表){
      函数体
    }
  在基类中的某个成员函数被声明为虚函数后
  此虚函数就可以在一个或多个派生类中被重新定义
  虚函数在派生类中重新定义时,其函数原型,包括返回类型,函数名,参数个数,参数类型的顺序
  都必须与基类中的原型完全相同
  构造函数不可以声明为虚函数,析构函数可以声明为虚函数
  在 15.cpp 中,函数调用 pb->show2(); 要在运行时确定所要调用的函数
  即要对该调用进行动态联编,因此,程序在运行时根据指针 pb 所指向的实际对象,调用该对象的成员函数
  我们把使用同一调用形式 pb->show2(); 调用同一类族中不同类的虚函数称为动态的多态性,即运行时的多态性
  案例:
    class A{
      public:
      virtual void fun1(){...}
      ...
    };
    class B:public A{
      public:
      void fun1(){...}
      ...
    };
  上述案例中只在基类 A 中显式定义了 fun1 为虚函数
  C++ 规定,如果在派生类中没有用 virtual 显式地给出虚函数声明
  这时系统就会遵循以下的规则来判断一个成员函数是否为虚函数
    1.是否同名
    2.参数个数与对应参数类型是否相同
    3.返回类型是否相同或是否满足赋值兼容规则的指针,引用型的返回类型
  满足上述所有条件即被自动确定为虚函数
  对虚函数的定义作几点说明:
    1.由于虚函数使用的基础是赋值兼容规则,而赋值兼容规则成立的前提条件是派生类从其基类公有派生
      因此,通过定义虚函数来使用多态性机制时,派生类必须从它的基类公有派生
    2.必须首先在虚函数中定义虚函数
      由于"基类"与"派生类"是相对的,因此,这项说明并不表明必须在类等级的最高层类中声明虚函数
      在实际应用中,应该在类等级内需要具有动态多态性的几个层次中的最高层类内首先声明虚函数
    3.在派生类对基类中声明的虚函数进行重定义时,关键字 virtual 可以写也可不写
      但在容易引起混乱的情况下,最好在对派生类的虚函数进行重定义时也加上关键字 virtual
    4.虽然使用对象名和点运算符的方式也可以调用虚函数
      但这种调用在编译时进行的是静态联编,他没有充分利用虚函数的特性
      只有通过基类指针访问虚函数时才能获得运行时的多态性
    5.一个虚函数无论被公有继承多少次,它仍然保持其虚函数的特性
    6.虚函数必须是其所在类的成员函数,而不能是友元函数,也不能是静态成员函数
      因为虚函数调用调用要靠特定的对象来决定该激活哪个函数
    7.内联函数不能是虚函数
      因为内联函数是不能在运行中动态确定其位置的
      即使虚函数在类的内部定义,编译时仍然将其看作是非内联的
    8.构造函数不能是虚函数,但是析构函数可以是虚函数,而且通常说明为虚函数

虚析构函数
  (案例见 15.cpp ) 
  当撤销指针 p2 所指的派生类的无名对象,而调用析构函数时
  采用了静态联编方式,只调用了基类的析构函数
  如果希望程序执行动态联编的方式,在用 delete 运算符撤销派生类的无名对象时
  先调用派生类的析构函数,再调用基类的构造函数
  可以将基类的析构函数声明为虚析构函数
  虚析构函数没有类型,也没有参数
  虚析构函数的定义一般格式:
    virtual ~类名(){
      函数体
    };
  虽然派生类的虚构函数与基类的析构函数名字不同
  但是如果将基类的析构函数定义为虚函数
  由该基类派生的所有派生类的析构函数也都自动成为虚函数

纯虚函数
  有时,基类往往表示一种抽象的概念,它并不与具体的事物相联系
  这时在基类中将某一成员函数定义为虚函数,并不是基类本身的要求,而是考虑到派生类的需要
  在基类中预留一个函数名,具体功能留给派生类根据需要去定义
  纯虚函数的一般形式:
    virtual 函数类型 函数名(参数表)=0;
  纯虚函数是在声明虚函数时被"初始化"为0的函数
  纯虚函数没有函数载体,基类中不可给出实现部分
  "=0"只是起形式上的作用,告诉编译系统这是"纯虚函数"
  纯虚函数不具备函数的功能,不能被调用
  *纯虚函数与 Java 中的抽象方法类似
  这就是多态性,对同一条消息,不同的对象有着不同的响应方式

抽象类
  如果一个类至少有一个纯虚函数,那么就称该类为抽象类
  定义抽象类的唯一目的是用它作为一个基类去建立派生类
  抽象类作为一种基本类型提供给用户,用户在这个基础上根据自己的需要定义出功能各异的派生类
  并用这些派生类去建立对象
  注意:
    1.由于抽象类中至少包含一个没有定义功能的纯虚函数
      因此,抽象类只能作为其它类的基类来使用,不能建立抽象类对象
    2.不允许从具体类派生出抽象类
      所谓具体类,就是不包含纯虚函数的普通类
    3.抽象类不能用作函数的参数类型,函数返回类型或显式转换的类型
    4.可以声明指向抽象类的指针或引用,此指针可以指向它的派生类,进而实现多态性
    5.如果派生类中没有定义纯虚函数的实现,而派生类中给出了基类纯虚函数的实现
      则该派生类就不再是抽象类了,它是一个可以建立对象的具体类了

运算符重载
  它是面向对象程序设计的重要特征
  运算符重载是对已有的运算符赋予多重含义,使同一个运算符作用于不同类型的数据导致不同的行为
  在 C++ 中经重载后的运算符能直接对用户自定义的数据进行操作运算
    int a=1,b=2;
    double c=3,d=4;
    cout << "a+b=" << a+b << ",c+d=" << c+d << endl;
    从上述代码可看到,运算符"+"可以用于不同类型的数据的加运算
    那是因为 C++ 针对预定义基本数据类型已经运算符对"+"做了适当的重载
    但 C++ 提供的预定义的基本数据类型终究是有限的
    在解决实际问题时往往需要使用更多的自定义类型,例如复数,矩阵等等
    C++ 为运算符重载提供了一种方法
    即在进行运算符重载时必须写一个运算符函数,其名字规定为 operator 后随一个要重载的运算符
      函数          功能
      operator+()   加法
      operator-()   减法
      operator*()   乘法
      operator/()   除法
      operator<()   小于
      ...
    这样,在编译时遇到名为 operator@ 的运算符函数( @ 表示所要重载的运算符)
    就检查传递给函数的参数类型,如果编译器在一个运算符的两边"看"到自定义的数据类型
    就执行用户自己的函数,而不是这些运算符的常规程序
    总之,运算符重载进一步提高了面向对象软件系统的灵活性,可扩充性和可读性

运算符重载函数作为类的友元函数
  由 16.cpp 可发现,这个运算符重载只能访问类中的公有数据成员,而不能访问类的私有数据成员
  运算符重载函数一般采用如下两种形式:
    1.定义为它将要操作的类的成员函数
      在 C++ 中可以把运算符函数重载为类的成员函数
      在类的内部将运算符函数重载为类的成员函数格式:
        返回类型 operator 运算符(形参表){
          函数体
        }
      也可在类中声明成员函数的原型,在类外定义
        class X{
          ...
          返回类型 operator 运算符(形参表);
          ...
        };
        返回类型 X::operator 运算符(形参表){
          函数体
        }
      在运算符参数的形参表中,若运算符是单目的,则形参表为空,参数可以被显式地(通过 this 指针隐含地)传递给成员运算符重载函数
      若运算符是双目的,则形参表有一个操作数,即有一个参数
    2.定义为类的友元函数
      在 C++ 中可以把运算符重载函数作为类的友元函数
      在类的内部函数原型的声明格式:
        class X{
          ...
          friend 返回类型 operator 运算符(形参表);
          ...
        };
      在类外定义友元运算符函数的格式:
        返回类型 operator 运算符(形参表){
          函数体
        }
      由于友元函数不是该类的成员函数,所以不需要缀上"类名::"
      友元函数没有 this 指针,重载自增运算符或自减运算符时应采用对象引用参数传递数据
      注意:
        1.有的 C++ 系统(如 Visual C++6.0 )没有完全实现 C++ 的标准
          它所提供的不带后缀的 .h 的头文件不支持把运算符函数重载为友元函数
          在 Visual C++6.0 中编译会出错,这时可采用带后缀的 .h 头文件
            #include<iostream.h>
        2.运算符重载函数 operator@() 可以返回任何类型,甚至可以是 void 类型
          但通常返回类型于它所操作的类型相同
          这样可使重载运算符用在复杂的表达式中
        3.有的运算符不能定义为友元运算符重载函数,如 = , 下标运算符[] , 函数调用运算符() 等等
        4.C++ 编译器根据参数的个数和类型来决定调用哪个重载函数
          因此,可以为同一个运算符定义多个运算符重载函数来进行不同的操作
        5.用友元函数重载单目运算符需要一个显式的操作数,即需要一个参数
          *注意与第一种形式的区别
  注意:
    1.C++ 中只能对已有地 C++ 运算符进行重载,不允许用户自定义新的运算符
      虽然有些程序语言将"**"作为指数运算符,但 C++ 不能重载"**",因为它不是 C++ 运算符
    2.C++ 中有一部分运算符不允许重载:
        运算符      名称
        .           成员访问运算符
        .*          成员指针访问运算符
        ::          作用域运算符
        sizeof      长度运算符
        ?:          条件运算符
    3.运算符重载是针对新类型数据的实际需要,对原有运算符进行适当的改造完成的
    4.重载不能改变运算符的操作对象(即操作数)的个数
      例如在 C++ 中运算符"+"是一个双目运算符(即只能带两个操作数),重载后仍为双目运算符,需要两个参数
    5.重载不能改变运算符原有的优先级
    6.重载不能改变运算符原有的结合特性
      例如在 C++ 中"*"和"/"都是左结合
        x=a/b*c; // 左结合
        x=a/(b*c); // 右结合
      我们无法重载运算符使它们变成右结合
    7.运算符重载函数的参数不能全部是 C++ 定义的基本函数类型
        int operator+(int a,int b){
          return a+b;
        }
      这项规定的目的是防止用户修改用于基本类型数据的运算符性质
      假设允许那么可有如下定义
        int operator+(int a,int b){
          return a-b;
        }
      当执行 1+1 时就产生问题了,显然是绝对不允许的
    8.双目运算符一般可以被重载为友元函数或成员函数
      但有一种情况必须使用友元函数
      例如将一个类 X 的对象与一个整数相加
        X::operator+(int n){
          return X(n,n+1);
        }
        x2=x1+10; // 这是没问题的,此语句被 C++ 编译系统解释为 x2=x1.operator(10);
      由于对象 x1 是运算符"+"的左操作数,所以它可以调用"+"运算符重载函数 operator+()
      但是换一下位置
        x2=10+x1; // 错误,此语句被 C++ 编译系统解释为 x2=10.operator(x1);
      由于左操作数是一个整数,而不是对象,编译时将出现错误
      解决方式是使用友元函数
        class X{
          ...
          friend X operator+(X x,int n);
          friend X operator+(int n,X x);
          ...
        }
        X operator+(X x,int n){
          ...
        }
        X operator+(int n,X x){
          ...
        }

前置运算符和后置运算符的重载
  自增运算符"++"和自减运算符"--"放置在变量的前面与后面其作用是有区别的
    x=i++; // 后置,先将i原值赋给x,然后i加1
    x=++i; // 前置,先把i加1,再把i值赋给x
  早期版本的 C++ 在重载"++"或"--"时,不能显式地区分是前置方式还是后置方式
  也就是说以下两条语句是完全相同的(运行 16.cpp 可知,目前版本两者是不同的)
    obj++;
    ++obj;
  在 C++ 2.1 及以后地版本中,编辑器可以通过在运算符函数参数中是否插入关键字 int 来区分这两种方式
  int 只是为了区分前置和后置的取别,无其它作用,也不必使用此参数,因此可不必写参数名,一般被传递给值0
    1.前置方式
        X.operator++(); // 成员函数
      或
        X.opeartor++(X &x); // 友元
    2.后置方式
        X.operator++(int); // 成员函数
      或
        X.opeartor++(X &x, int); // 友元

重载插入运算符和提取运算符
  1.重载插入运算符"<<"
    在 C++ 中,"<<"是被定义为左位移运算符
    由于在 iostream 头文件中对它进行了重载,使它能用作基本类型数据的输出运算符
    插入运算符(也称输出运算符)"<<"是一个双目运算符,有两个操作数
    左操作数为输出流类 ostream 的一个流对象(如 cout )
    右操作数为一个系统预定义的基本类型的常量或变量
    在头文件 iostream 中有一组运算符函数对运算符"<<"进行重载
    以便能用它输出各种标准类型的数据
    原型具有的形式:
      ostream& operator<<(ostream& 类型名);
    类型名包括 int float double char* char 等 C++ 基本类型
    当系统执行
      cout<<"123";
    操作时,就是调用插入运算符重载函数
      ostream& operator<<(ostream& char*);
    以上语句相当于
      cout.ostream<<("123");
    它的功能是将字符串"123"插入到流对象 cout 中
    cout 为标准输出流对象,它与标准输出设备(通常为显示器)连在一起
    于是在显示器屏幕上显示出字符串"123"
    C++ 对插入运算符"<<"的功能进行了扩充
    可以通过重载运算符"<<"实现用户自定义类型的输出
    定义插入运算符重载函数的一般格式:
      ostream& operator<<(ostream &out,自定义类名& obj){
        out<<obj.item1;
        out<<obj.item2;
        out<<obj.item3;
        ...
        return out;
      }
    函数中第一个参数 out 是 ostream 类对象的引用
    这意味着 out 必须是输出流对象,它可以是其它任何正确的标识符,但必须与 return 后面的标识符相同
    第二个参数 obj 为用户自定义类型的对象的引用
    item1 , ... 为用户自定义类型中的数据成员
    插入运算符重载函数不能是所操作的类的成员函数,但可以是该类的友元函数或普通函数
  2.重载提取运算符">>"
    在 C++ 中,">>"为右移运算符
    由于在 iostream 头文件中对它进行了重载,使它能用作基本类型数据的输入运算符
    插入运算符(也称输入运算符)">>"也是一个双目运算符,有两个操作数
    左操作数为输入流类 istream 的一个对象(如 cin)
    右操作数为系统预定义的任何基本数据类型的变量
    在头文件 iostream 中也有一组提取运算符函数对运算符">>"进行重载,以便能用输入各种标准类型的数据
    其原型具有的形式如下
      istream& operator>>(istream& 类型名 &);
    其中类型名指 int float double char* char 等 C++ 标准类型
    当系统执行
      int x;
      cin >> x;
    操作时,将根据实参 x 的类型调用相对应的提取运算符重载函数
    并把 x 传送给对应的形参
    接着从标准输入输出流对象 cin(它与标准输入设备连在一起,通常为键盘)读入一个值并赋值给 x(因为形参是 x 的引用)
    自定义提取运算符函数格式:
      istream& operator>>(istream& in,自定义类名& obj){
        in>>obj.item1;
        in>>obj.item2;
        in>>obj.item3;
        ...
        return in;
      }
    函数中第一个参数 in 是 istream 类对象的引用
    这意味着 in 必须是输入流对象,它可以是其它任何正确的标识符但必须与 return 后面的标识符相同
    第二个参数 obj 为用户自定义类型的对象的引用,
    item1 ,item2, ... 为用户自定义类型中的数据成员

类型转换
  1.系统预定义类型间的转换
    C++ 提供两种类型转换方式
    a.隐式转换
      某些不同类型的数据之间可以自动转换
        int x=3.5,y;
        y=3.5+x;
      C++ 编译系统对3.5是作为 double 处理的
      它先将 x 的值转换成 double 型,然后与 3.5 相加得到 8.5
      然后向整型变量 y 赋值时,将 8.5 转换成整数 8
      这种转换是由 C++ 编译系统自动完成的,用户不需要干预,称为隐式类型转换
    b.显式类型转换
      编程人员在程序中可以明确地指出将一种数据类型转换成另一种指定的类型
      这种转换称为显式类型转换
      常用的显式转换有如下方法:
        1>(类型名)表达式
          C 语言中采用的形式
            double i=2.2,j=3.3;
            cout<<(int)(i+j);
          将表达式 i+j 的值 5.4 强制转换成整数 5 后输出
        2>类型名(表达式)
          C++ 语言中采用的形式
            double i=2.2,j=3.3;
            cout<<int(i+j);
          将表达式 i+j 的值 5.4 强制转换成整数 5 后输出
      提倡使用采用 C++ 提供的方法
  2.类类型与系统预定义类型间的转换
    对于用户自定义的类类型而言,通常有两种方法
      a.通过转换构造函数进行类型转换
        转换构造函数也是构造函数的一种,它具有类型转换的作用
        即将一个其它类型的数据转换成它所在类的对象
        方法如下:
          1>先声明一个类
          2>在这个类中定义一个只有一个参数的构造函数,参数是待转换类型的数据,在函数体中指定转换的方法
          3>使用上述构造函数进行转换
              类名(待转换类型的数据)
        注意:
          1>转换构造函数只有一个参数
          2>转换构造函数不经可以是系统预定义的基本类型数据转换成类的对象
            也可以是将另一个类的对象转换成转换构造函数所在的类对象
      b.通过类型转换函数进行类型转换
        由上述方法可知,通过转换构造函数可将一个指定类型的数据转换为类的对象
        但不能反过来将一个类的对象转换成其它类型的数据
        C++ 提供了一个称为类型转换函数的函数来解决这个问题
        他将一个类的对象转换为另一个类型的数据,定义类型转换函数的一般格式:
          operator 目标类型(){
            函数体
          }
        目标类型为希望转换成的类型名,它既可以是预定义的基本数据类型,也可以是其它的类型
        类型转换函数的函数名为"operator 目标类型"
        在函数名前面不能指定函数返回类型,也不能有参数
        函数体的最后一条语句是 return 语句,返回值的类型是该函数的目标类型
          operator double(){
            return real;
          }
        这个类型转换函数的函数名是"operator double"
        希望转换成的目标类型为 double
        函数体为"return real;"
        这个类型转换函数的作用是将 Complex 类对象转换为一个 double 类型的数据
        注意:
          1>类型转换函数只能定义为一个类的成员函数,而不能定义为类的友元函数
            类型转换函数也可以在类体中声明函数原型,而将函数定义放在类外
          2>类型转换函数既没有参数,也不能在函数名前面指定函数返回类型
          3>类型转换函数中必须有 return 语句,即必须送回目标类型的数据作为函数的返回值
          4>一个类可以定义多个类型转换函数
            C++ 编译器将根据类型转换函数名自动地选择一个合适的类型转换函数予以调用

模板
  模板是 C++ 的一个重要特性
  模板是实现代码重用机制的一种工具
  它可以实现类型参数化,即把类型定义为参数,从而实现了代码的重用
  使得一段程序可以用于处理多种不同类型的对象
  利用模板机制可以显著减少冗余信息,能大幅度地节约程序代码,提高程序设计的效率,进一步提高面向对象程序的可重用性和可维护性

为什么需要模板?
  有一个需求:定义一个求最大值函数 Max() 并需要对不同数据类型分别定义不同的函数
    int Max(int a,int b){ return (a>b)?a:b; }
    double Max(double a,double b){ return (a>b)?a:b; }
    long Max(long a,long b){ return (a>b)?a:b; }
    ...
  虽然通过重载使它们拥有同样的函数名,但还是不得不为每一个函数编写一组代码
  如果能够使这些函数只写一遍,即写一个通用的函数,而它可以适用于多种不同的数据类型
  便会使代码的可重用性大大提高,从而提高软件的开发效率
  C++ 提供的模板就可以解决这个问题
  模板是实现代码重用机制的一种工具,它可以实现类型参数化,即把类型定义为参数,从而实现了真正的代码可重用性
  使用模板可以大幅度地提高程序设计的效率
  模板分为函数模板和类模板
  它们分别允许用户构造模板函数和模板类

函数模板
  函数模板实际上是建立一个通用函数
  其函数返回值类型和形参类型不具体指定,用一个虚拟的类型来代表
  这个通用函数就称为函数模板
  函数模板的声明:
    template<typename 类型参数>
    返回类型 函数名(模板形参表){
      函数体
    }
  也可以定义如下形式:
    template<class 类型参数>
    返回类型 函数名(模板形参表){
      函数体
    }
  template 为声明模板的关键字
  类型参数(通常用 C++ 标识符表示,如 T 或 Type 等)实际上是一个虚拟的类型名
  使用前并未指定它是哪一种具体的类型,但使用函数模板时,必须将类型参数实例化
  类型参数前需要加关键字 typename 或 class
  typename 和 class 的作用相同,都表示其后的参数是一个虚拟的类型名(即类型参数)
  早期版本的 C++ 程序都用关键字 class
  由于 class 容易与类名混淆,所以后来标准 C++ 又增加了关键字 typename
  二者可以互换,但 typename 的含义比 class 清晰
    template<typename T>
    T Max(T a,T b){
      return (a>b)?a:b;
    }
  也可定义成如下形式
    template<typename T>
    T Max(T a,T b){
      return (a>b)?a:b;
    }
  从 18.cpp 中我们可以看出,函数模板提供了一类函数的抽象
  它以类型参数 T 为函数参数及函数返回值的虚拟类型
  函数模板经实例化而生成的具体函数称为模板函数
  函数模板代表了一类函数,模板函数表示表示某一具体的函数
  函数模板与模板函数的关系
                        |---实例化--->模板函数:Max(int,int)
                        |
    函数模板:Max(T,T)---|----实例化--->模板函数:Max(double,double)
                        |
                        |---实例化--->模板函数:Max(long,long)
                        |...(more)
  注意:
    1.在函数模板中允许使用多个类型参数
      每个类型前必须有关键字 typename 或 class
    2.在 template 语句与函数模板定义语句之间不允许插入别的语句
    3.同一般函数一样,函数模板也可以重载
    4.函数模板与同名的非模板函数可以重载
      此种情况下的调用顺序是先匹配非模板函数,未匹配到再匹配函数模板

类模板
  类模板的定义格式:
    template<typename 类型参数>
    class 类名{
      类成员声明
    };
  也可以定义如下形式:
    template<class 类型参数>
    class 类名{
      类成员声明
    };
  template 为声明模板的关键字,表示声明一个模板
  类型参数实际上是一个虚拟的类型名,现在并未指定它是哪一种具体的类型,但使用类模板时,必须将类型参数实例化
  类型参数前需要加关键字 typename 或 class ,都是表示其后的参数是一个虚拟的类型名(即类型参数)
  用类模板定义对象的一般格式:
    类模板名<实际类型名> 对象名;
    类模板名<实际类型名> 对象名(实参表列);
  在类模板体外定义的成员函数的一般形式:
    template<typename 类型参数>
    函数类型 类名<类型参数>::成员函数名(形参表){
      成员函数体
    }

C++ 输入/输出流
  在 C++ 中输入输出是通过流来完成的
  流指数据从一个源流到一个目的的抽象
  它负责在数据的生产者(源)和数据的消费者(目的)之间建立关系,并管理数据的流动
  凡是数据从一个地方传输到另一个地方的操作都是流的操作
  从流中提取数据称为输入(又称提取)操作
  向流中添加数据称为输出(又称插入)操作
  C++ 的输入输出是以字节流的形式实现的
  在输入操作中,字节流从输入设备流向内存
  在输出操作中,字节流从内存流向输出设备
  字节流可以是 ASCII 字符,二进制形式的数据,图像,音频视频等信息
  文件和字符串也可以看成有序的字节流,分别称为文件流和字符串流
  与 C 一样 C++ 中也没有输入输出语句
  C++ 编译系统带有一个面向对象的输入输出软件包,它就是 C++ 的 I/O 流类库
  在 I/O 流类库中包含许多用于输入输出的类,称为流类,用流类定义的对象称为流对象

用于输入输出的头文件
  I/O 流类库中的各种的类的声明被放在相应的头文件中,常用的头文件如下所示:
    1.iostream
      包含了对输入输出流进行操作所需的基本信息
      使用 cin cout 等流对象进行针对标准设备的 I/O 操作时,须包含此头文件
    2.fstream
      用于用户管理文件的 I/O 操作
      使用文件流对象进行针对磁盘文件的操作,须包含此头文件
    3.strstream
      用于字符串流的 I/O 操作
      使用字符串流对象进行针对内存字符串空间的 I/O 操作,须包含此头文件
    4.iomainip
      用于输入输出的格式控制
      在使用 setw fixed 等大多数操作符进行格式控制时,须包含此头文件

用于输入输出的流类
  常用的流类如下所示:
    类名        说明                                      头文件
    -抽象流基类-
    ios         流基类                                    iostream
    -输入流类-                                            
    istream     通用输入流类和其它输入流的基类             iostream
    ifstream    输入文件流类                              fstream
    istrstream  输入字符串流类                            strstream
    -输出流类-
    ostream     通用输出流类和其它输出流的基类             iostream
    ofstream    输出文件流类                              fstream
    ostrstream  输出字符串流类                            strstream
    -输入输出流类-
    iostream    通用输入输出流类和其它输入输出流的基类      iostream
    fstream     输入输出文件流类                           fstream
    strstream   输入输出字符串流类                         strstream
  ios 是一个抽象基类,类 istream 和 ostream 是通过单继承从基类 ios 派生而来的
  类 iostream 是通过多重继承从 istream 和 ostream 派生而来的
           |--->istream--->|
    ios--->|               |--->iostream
           |--->ostream--->|
  ios 作为流类库中的一个基类,它还可以派生出许多类
  其中有四个直接派生类
  即输入流类(istream),输出流类(ostream),文件流类(fstreambase)和串流类(strstreambase)
  这四种流作为流库中的基本流类
  以上述四种基本流类为基础还可以派生出多个实用的流类
  例如:ifstream,ofstream,fstream,istrstream,ostrstream,strstream等

预定义的流对象
  用流类定义的对象称为流对象
  与输入设备(如键盘)相联系的流对象称为输入流对象
  与输出设备(如屏幕)相联系的流对象称为输出流对象
  C++ 中包含几个预定义的流对象
  标准输入流对象 cin ,它是 istream 类的对象,它与标准输入设备(通常指键盘)相联系
  标准输出流对象 cout ,它是 ostream 类的对象,它与标准输出设备(通常指显示器)相联系
  非缓冲型的标准出错流对象 cerr ,它是 ostream 类的对象,它与标准错误输出设备(通常指显示器)相联系
  缓冲型的标准出错流对象 clog ,它是 ostream 类的对象,它与标准错误输出设备(通常指显示器)相联系

输入输出流的成员函数
  在 C++ 程序中除了用 cout 和插入运算符"<<"实现输出,用 cin 和提取运算符"<<"实现输入外
  还可以用类 istream 和类 ostream 流对象的一些成员函数实现字符的输出和输入
  1.put 函数
    put 函数用于输出一个字符,其常用的调用形式为
      cout.put(单字符);
    或
      cout.put(字符型变量);
    使用案例
      cout.put('A');
    将字符 A 显示在屏幕上,它与语句
      cout<<'A';
    等价,不同之处是 put 函数的参数不但可以是字符,还可以是字符的 ASCII 代码(也可以是一个整型表达式)
      cout.put(65);
    或
      cout.put(20+45);
    都可以将 A 显示在屏幕上
      cout.put(65),cout.put(66),cout.put(67),cout.put('\n');
  2.get 函数
    与提取运算符">>"类似,不同之处是 get 函数在读入数据时可以包括空白字符
    而提取运算符">>"在默认情况下拒绝接收空白字符
      cin.get(字符型变量)
    其作用是从输入流中读取一个字符(包括空白字符)赋给字符型变量
    如果成功则函数返回非0值,如果失败(遇文件结束符 EOF )则函数返回0值
    当输入"Ctrl+z"及回车时,程序读入的值是 EOF ,程序结束
  3.getline 函数
    其功能是从输入流读取 n-1 个字符
    赋给指定的字符数组(或字符指针指向的数组)
    然后插入一个字符串结束标志'\n'
    如果在读取 n-1 个字符之前遇到指定的终止字符则提前结束读取
    然后插入一个字符串结束标志'\n'
  4.ignore 函数
    其功能是跳过输入流中 n 个字符(默认个数为1)或在遇到指定的终止字符(默认终止字符是 EOF )时提前结束
      cin.ignore(n,终止字符);
    ignore 函数可以不带参数或只带一个参数
      cin.ignore(); // 只跳过1个字符( n 的默认值为1,默认终止字符是 EOF )
    相当于
      cin.ignore(1,EOF);

输入输出的格式控制
  1.使用流成员函数进行输入输出格式控制
    ios 类中有几个流成员函数可以用来对输入输出进行格式控制
      流成员函数        功能
      setf(flags)      设置状态标志
      unsetf(flags)    清除状态标志
      width(n)         设置字段域宽为n位
      fill(char ch)    设置填充字符 ch
      precision(n)     设置实数的精度为n位,在以普通十进制小数形式输出时n代表有效数字
                       在以 fixed(固定小数位数) 形式和 scientific(指数) 形式输出时 n 为小数位数
    流成员函数 setf 和 unsetf 括号中的参数是用状态标志定的
    状态标志在类 ios 中被定义成枚举值,所以在引用这些状态标志时要在前面加上"ios::"
      状态标志         功能                                                输入/输出
      ios::skipws     跳过输入中的空白符                                   输入
      ios::left       输出数据在本域宽范围内左对齐                          输出
      ios::right      输出数据在本域宽范围内右对齐                          输出
      ios::internal   数据的符号位左对齐,数据本身右对齐                      输出
                      符号和数据之间为填充符                                
      ios::dec        设置整数的基数为10                                    输入/输出
      ios::oct        设置整数的基数为8                                     输入/输出
      ios::hex        设置整数的基数为16                                    输入/输出
      ios::showbase   输出整数时显示基数符号                                输入/输出
                      八进制数以 0 打头,十六进制数以 0x 打头                 
      ios::showpoint  浮点数输出时带有小数点                                输出
      ios::uppercase  在以科学表示法格式 E 和以十六进制输出字母时用大写表示   输出
      ios::showpos    正整数前显示"+"符号                                   输出
      ios::scientific 用科学表示法格式(指数)显示浮点数                       输出
      ios::fixed      用定点格式(固定小数位数)显示浮点数                     输出
      ios::unitbuf    完成输出操作后立即刷新所有的流                         输出
      ios::stdio      完成输出操作后刷新 stdout 和 stderr                   输出
    a.设置状态标志流成员函数 setf
      设置状态标志,即是将某一状态标志位置"1",可使用 setf 函数
      一般格式:
        long ios::setf(long flags)
      使用时,其一般的调用格式:
        流对象.setf(ios::状态标志);
      注意:
        1>状态标志在 ios 中被定义成枚举值,所以在引用时要在前面加上"ios::"
        2>在使用 setf 函数设置多项标志时,中间应该用或运算符"|"分隔
    b.清除状态标志流成员函数 unsetf
      清除某一状态标志,即是将某一状态标志位置"0",可使用 unsetf 函数,一般格式为
        long ios::unsetf(long flags)
      使用时的调用格式:
        流对象.unsetf(ios::状态标志);
    c.设置域宽流成员函数 width
        int ios::width(int n)
      使用时的调用格式:
        流对象.width(n);
      所设置的域宽仅对下一个流输出操作有效
    d.设置实数的精度流成员函数 precision
        int ios::precision(int n);
      使用时的调用格式:
        流对象.precision(n);
    e.填充字符流成员函数 fill
      当输出值不满域宽时用填充字符填充
      默认情况下填充字符为空格
      在使用填充字符函数 fill 时,必须与 width 函数相配合,否则没有意义
        char ios::fill(char ch) 
      ch 为所要填充的字符,使用时的调用格式:
        流对象.fill(ch);
    注意:
      1>默认情况下,域宽取值为0,其意义为无域宽,即数据按自身的宽度打印
      2>当用 width 函数设置了宽域后,只对紧跟它的第一个输出有影响,之后又恢复为默认域宽0
        而调用 precision 函数和 fill 函数的设置,在程序中一直有效,直至被重新设置
        若要更改为另一状态应调用 unsetf 函数,先终止原来的设置状态,然后再设置其它状态
      3>当显示数据所需的宽度比使用 ios::width() 设置的宽度小时,空余的位置用填充字符来填充
        默认情况下的填充字符是空格
        填充字符的填充位置由 ios::left 和 ios::right 规定
  2.使用预定义的操作符进行输入输出格式控制
    使用 ios 类中的成员函数进行输入输出格式控制时,每个函数的调用都需要写一条语句
    而且不能将它们直接嵌入到输入输出语句中去,这显然用起来不方便
    C++ 提供了另一种进行输入输出格式控制的方法,这一方法使用了一种称为操纵符(也称为操作符或控制符)的特殊函数
    在很多情况下,使用操纵符比 ios 状态标志和成员函数要方便
    操纵符有不带参数和带参数两类
    所有不带形参的操纵符都定义在头文件 iostream.h 中
    带形参的操纵符则定义在头文件 iomainip.h 中
      操纵符            功能                                         输入/输出
      dec               设置整数的基数为10                            输入+输出
      hex               设置整数的基数为10                            输入+输出
      oct               设置整数的基数为10                            输入+输出
      ws                用于在输入时跳过开头的空白字符                 输入
      endl              输出一个换行符并刷新输出流                     输出
      ends              插入一个空字符 null ,通常用来结束一个字符串     输出
      flush             刷新一个输出流                                输出
      setbase(n)        设置整数的基数为 n(取值:0/8/10/16)            输入+输出
                        n 的默认值为0,即以十进制形式输出
      setfill(c)        设置 c 为填充字符,默认时为空格                 输出
      setprecision(n)   设置实数的精度为 n 位,在以一般十进制小数形式    输出
                        输出时 n 代表有效数字,在以 fixed(固定小数位数)
                        形式和 scientific(指数) 形式输出时 n 为小数
                        位数设置域宽为n
      setw(n)           设置域宽为 n                                  输出
      setiosflags(f)    设置由参数 f 指定的状态标志                    输入+输出
      resetiosflags(f)  终止由参数 f 指定的状态标志                    输入+输出
    操纵符 setiosflags 和 resetiosflags 要带上状态标志才能使用,其常用的状态标志如下所示:
      操纵符                         功能
      setiosflags(ios::left)         数据按域宽左对齐输出
      setiosflags(ios::right)        数据按域宽右对齐输出
      setiosflags(ios::fixed)        固定的小数位数显示
      setiosflags(ios::scientific)   设置浮点数以科学表示法(即指数形式)显示
      setiosflags(ios::showpos)      在正数前添加一个"+"号输出
      setiosflags(ios::uppercase)    在以科学表示法格式 E 和以十六进制输出字母时用大写表示
      resetiosflags(f)               终止已设置的状态标志,在括号中应指定 f 的内容
    在进行输入输出时,操纵符被嵌入到输入或输出链中,用来控制输入输出的格式,而不是执行输入或输出操作
    使用操纵符必须含有 #include<iomanip> 预编译命令
  3.使用用户自定义的操作符进行输入输出格式控制
    C++ 允许用户自定义操纵符,合并程序中频繁使用的输入输出操作,使输入输出密集的程序更加清晰有效,并可避免意外错误
    输出流定义操纵符函数定义形式:
      ostream &操作符名(ostream &stream){
        自定义代码
        return stream;
      }
    输入流定义操纵符函数定义形式:
      istream &操纵符(istream &stream){
        自定义代码
        return stream;
      }
    以上操纵符函数中返回流对象 stream(也可用其它标识符,但与形参表中的流对象必须相同)是一个关键
    否则操纵符就不能用在流的输入输出操作序列中

文件
  指存放在外部介质上的数据的集合
  根据文件中数据的组织形式可分为两类:
    1.文本文件
      文本文件又称 ASCII 文件,它的每个字节存放一个 ASCII 代码,代表一个字符
    2.二进制文件
      二进制文件是把内存中的数据按其在内存中的存储形式原样写到磁盘上存放
      假设有一个正数 10000
      在内存中占两个字节,如果按文本形式需占5个字节,而按二进制形式输出则在磁盘上只占两个字节
      用文本形式输出时,一个字节对应一个字符,因而便于对字符进行逐个处理,也便于输出字符,缺点是占存储空间较多
      用二进制形式输出数据,可以节省存储空间和转换时间,但一个字节不能对应一个字符,不能直接以字符形式输出
      对于需要暂时保存在外存上,以后又需要输入到内存的中间结果数据,通常用二进制形式保存
  在 C++ 中进行文件操作的一般步骤:
    1.为要进行文件操作的文件定义一个流对象
    2.建立(或打开)文件
      如果文件不存在则建立该文件
      如果磁盘上已存在该文件则打开它
    3.进行读写操作
      在建立(或打开)的文件基础上执行所要求的输入或输出操作
    4.关闭文件
      当完成输入输出操作时,应把已打开的文件关闭
  
文件的打开与关闭
  在 C++ 中,打开一个文件就是将这个文件与一个流对象建立关联
  关闭一个文件就是取消这种关联
  用于文件输入输出的文件流类
    类名        说明             功能
    ifstream    输入文件流类     用于文件的输入
    ofstream    输出文件流类     用于文件的输出
    fstream     输入输出文件流类 用于文件输入输出
  这三个文件流类都定义在头文件 fstream 中
  执行文件的输入输出的主要步骤:
    1.在程序中包含头文件 fstream
    2.建立流对象
    3.使用成员函数 open 打开文件,使某一指定的磁盘文件与某一已定义的文件流对象建立关联
    4.进行读写操作
    5.使用 close 函数将打开的文件关闭
  open 函数是上述 3 个流类的成员函数,其原型是在 fstream 中定义的
  在 ifstream , ofstream 和 fstream 类中均有定义
  调用成员函数 open 的一般形式:
    文件流对象.open(文件名,使用方式);
  其中"文件名"可以包括路径,若是缺省路径,则默认为当前目录下的文件
    方式              功能
    ios::in           以输入方式打开文件,该文件必须存在
    ios::out          以输出方式打开文件,如果已有此名字的文件,则将其原有的内容全部清除,若不存在则新建
    ios::app          以输入方式打开文件,写入的数据添加到文件末尾
    ios::ate          打开一个已有的文件,把文件指针移到文件末尾
    ios::trunc        打开一个文件,若文件已存在,删除其中全部数据,若文件不存在,则建立新文件
                      若已指定了 ios::out 方式,而未指定 ios::app ios::in 则同时默认此方式
    ios::nocreate     打开一个已有的文件,若文件不存在,则打开失败(不创建)
    ios::noreplase    打开一个文件,若文件不存在,则建立新文件,若存在,则打开失败
    ios::binary       以二进制方式打开一个文件,若不指定此方式,则默认为文本文件
  说明:
    1.新版本的 C++ 系统 I/O  类库中不提供 ios::nocreate 和 ios::noreplase
    2.每一个打开的文件都有一个文件指针,该指针的初始位置由输入/输出的方式决定
      每次读写都从文件指针的当前位置开始
      每读一个字节,指针就后移一个字节
      当文件指针移到最后,就会遇到文件结束符 EOF(文件结束符也占一个字节,其值为-1)
      此时流对象的成员函数 eof 的值为非0值(一般设为1),表示文件结束了
  文件的关闭
    流对象.close();

文本文件的读写
  案例见 21.cpp

二进制文件的读写
  案例见 21.cpp

用 read 函数和 write 函数读写二进制文件
  有时需要读写一组数据(如一个结构变量的值)
  为此 C++ 提供了两个函数 read 和 write 用来读写一个数据块
  该两个函数的调用格式:
    inf.read(char *buf,int len);
    outf.write(const char *buf,int len);
  1.read
    read 是流类 istream 中的成员函数
    第一个参数 buf 是一个指针,它指向读入数据所存放的内存空间的起始地址
    第二个参数 len 是一个整数值,它是要读入的数据的字节数
    read 函数功能:
      从与输入文件流对象 inf 相关联的磁盘文件中,读取 len 个字节(或遇 EOF 结束)
      并把它们存放在字符指针 buf 所指的一段内存空间内
      如果在 len 个字节(字符)被读出之前就达到了文件尾,则 read 函数停止执行
  2.write
    write 是流类 ostream 的成员函数
    参数的含义及调用注意事项与 read 函数相似
    write 函数功能:
      将字符指针 buf 所给出的地址开始的 len 个字节的内容不加转换地
      写到与输出文件流对象 outf 相关联的磁盘文件中
  注意,第一个参数的数据类型为 char*，如果是其它类型的数据,必须进行类型转换
    int array[]={1,2,3};
    read((char *)&array,sizeof(array));
  上述案例定义了一个整型数组 array ,为了读入它的全部数据
  必须在 read 函数中给出它的首地址,并把它转换为 char* 类型

检测文件结束
  在文件结束的地方有一个标志位,记为 EOF(end of file)
  采用文件流方式读取文件时使用成员函数 eof() 可以检测到这个结束符
  如果该函数的返回值非0则表示到达文件尾,返回值为0表示未到达文件尾
  该函数的原型:
    int eof();
  调用方法:
    ifstream ifs;
    ...
    if(!ifs.eof())
      ...
  另一个检测方法就是检查该流对象是否为0,为0表示文件结束
    ifstream ifs;
    ...
    if(!ifs) // 尚未到达文件尾
      ...

二进制数据文件的随机读写
  为了增加对文件访问的灵活性
  C++ 系统总是用读或写文件指针记录文件的当前位置
  在类 istream 及类 ostream 中定义了几个与读或写文件指针相关的成员函数
  使我们可以在输入输出流内随机移动文件指针,从而可以对文件的数据进行随机读写
  类 istream 提供了3个成员函数来对读指针进行操作
    tellg()                 返回输入文件读指针的当前位置
    seekg(文件中的位置)      将输入文件中读指针移到指定的位置
    seekg(位移量,参照位置)   以参照位置为基准移动若干字节
  函数参数中的"文件中的位置"和"位移量"都是 long 型整数,以字节为单位
  "参照位置"可以是以下三者之一:
    ios::beg   从文件开头计算要移动的字节数
    ios::cur   从文件指针的当前位置计算要移动的字节数
    ios::end   从文件末尾计算要移动的字节数
  假设 inf 是类 istream 的一个流对象
    inf.seekg(-50,ios::cur);
  表示使输入文件中的读指针以当前位置为基准向前(文件的开头方向)移动50字节
    inf.seekg(-50,ios::end);
  表示使输入文件中的读指针从文件的末尾位置前移50字节
  类 ostream 提供了3个成员函数来对写指针进行操作
    tellp()                 返回输出文件写指针的当前位置
    seekp(文件中的位置)      将输出文件中写指针移到指定的位置
    seekp(位移量,参照位置)   以参照位置为基准移动若干字节
  函数 seekg 和 seekp 的第二个参数可以省略,默认 ios::beg,即从文件开头来计算要移动的字节数
    inf.seekg(50);
  表示使输入文件中的读指针从文件的开头位置后移50个字节
  注意:
    1."g"是 get 的第一个字母,因此带"g"的函数都是输入函数
      "p"是 put 的第一个字母,因此带"p"的函数都是输出函数

异常处理和命名空间
  异常处理和命名空间是 C++ 发展后期增加的新功能
  以帮助程序设计人员更方便地进行程序地设计和调试工作
  异常处理是对所能预料的运行错误进行处理的一套实现机制,它可以让 C++ 程序在环境出现意外或用户操作不当地情况下做出正确合适的处理和防范
  命名空间是一个由程序设计者命名的内存区域,用来处理程序中常见的同名冲突问题

异常处理
  程序中的错误分为两种
    1.编译时的错误
      主要为语法错误
    2.运行时的错误
      无法预料,如算法错误
      无法避免,如内存空间不够
      函数调用错误,如无法打开文件,数组越界等等
  程序在运行过程中出现的错误统称为异常,对异常的处理称为异常处理

异常处理的方法
  C++ 处理异常的机制是由检查(try),抛出(throw)和捕获(catch)3本部分构成
  1.异常的抛出
    throw 语句格式:
      throw 表达式;
    通过 throw 语句抛出异常给调用者
    该异常由之匹配的 catch 语句来捕获
    "表达式"是表示抛出的异常类型,异常类型由表达式的类型来表示
  2.异常的捕获
    try-catch 语句格式:
      try{
        被检查的复合语句
      }
      catch(异常类型声明 1){
        进行异常处理的复合语句1
      }
      catch(异常类型声明 2){
        进行异常处理的复合语句2
      }
      ...
      catch(异常类型声明 n){
        进行异常处理的复合语句n
      }
    "被检查的复合语句"称为代码的保护段
    "异常类型声明"指明 catch 子句处理的异常的类型
    catch 捕获到异常后,由子句检查异常的类型
    即检查 throw 后表达式的数据类型与哪一个 catch 子句的异常类型的声明一致
    若一致则执行相应的异常处理程序(该子句后的复合语句)
    注意:
      a.如果在 catch 子句中没有指定异常信息的类型,而用了删节号"...",则表示它可以捕获任何类型的异常信息
      b.在 throw 语句中可以不包括表达式
          throw;
        此时它将把当前正在处理的异常信息再次输出,给其上一层的 catch 块处理
      c.C++ 中,一旦抛出一个异常,而程序又不捕获
        那么系统就会调用一个系统函数 terminate,由它调用 abort 终止程序

命名空间
  产生背景
    一个大型软件通常由多个模块组成的,这些模块往往是由多人合作完成的
    不同的人分别完成不同的模块,最后组合成一个完整的程序
    假如不同的人分别定义了函数和类,放在不同的头文件中
    在主文件需要用这些函数和类时,就用 #include 命令行将这些头文件包括进来
    由于各头文件是由不同的人设计的,有可能在不同的头文件中用了相同的名字来定义的函数或类
    这样在程序中就会出现命名冲突,就会引起程序出错
    另外,引用第三方库也容易产生同样的问题
    为了解决该问题, ANSI C++ 引入了命名空间,用来处理程序中常见的同名冲突问题
  所谓命名空间,实际就是一个由程序设计者命名的内存区域
  程序设计者可以根据需要指定一些有名字的命名空间,将各命名空间中声明的标识符与该命名空间标识符建立关联
  保证不同命名空间的同名标识符不发生冲突
    namespae NS{
      int i=5;
      int j=10;
    };
  namespae 是定义命名空间的所必须写的关键字
  NS 是用户指定的命名空间的名字
  花括号内是命名空间的作用域
  声明了命名空间后,就可以解决名字冲突的问题
  C++ 中命名空间的作用类似于操作系统中的目录和文件的关系
  由于文件多,容易重名,于是人们设立若干子目录,把文件分别放到不同的子目录中,不同子目录中的文件可以同名
  调用文件时应指出文件路径
  除了用户可以声明自己的命名空间外
  C++ 还定义了一个标准命名空间 std
    using namespace std;
  其含义就是使用标准命名空间 std
  std(standard 的缩写) 是标准 C++ 指定的一个命名空间
  标准 C++ 库中的所有标识符都是在这个名为 std 的命名空间中定义的
  或者说标准头文件(如 iostream)中的函数,类,对象和类模板是在命名空间 std 中定义的
  如果要使用输入输出流对象(如 cin cout),就要告诉编译器该标识符可在命名空间 std 找到
  有两种方法:
    1.在源文件中使用"using namespace std;"
    2.在该标识符前面加上命名空间及作用运算符"::"
        std::cout<<std::"hi!"<<std::endl;

头文件命名规则
  在 C 语言中头文件用 .h 作为后缀
  为了兼容 C ,许多早期版本的编译系统头文件都是采用"*.h"形式
  但后来 ANSI C++ 建议头文件不带后缀".h"
  为了使原来编写的 C++ 程序能够运行,即可采用 C++ 中不带后缀的头文件,也可以采用 C 语言中带后缀的头文件
    1.带后缀的头文件的使用
      不必用命名空间
        #include<iostream.h>
    2.不带后缀的头文件的使用
      为了表示 C++ 与 C 语言的头文件既有联系又有区别
      C++ 所用的头文件不带后缀字符 .h 而是在 C 语言相应的头文件名之前加上前缀字符 c
      例如, C 语言中的头文件 stdio.h ,在 C++ 中相应的头文件名为 cstdio
      C 语言中的头文件 string.h ,在 C++ 中相应的头文件名为 cstring
      此外,需要在程序中声明命名空间 std
        #include<cstdio>
        #include<cstring>
        using namespace std;
  两种方法等价