前言
  它是对 C 语言的扩充
  主要是引进面向对象机制
  最初的 C++ 被称为"带类的C",1983年正式取名为 C++
  特点:
    1.C++ 是 C 的超集
      C++ 保持与 C 语言的兼容,这使得许多 C 代码不经修改就可以为 C++ 所用
    2.C++ 保持了 C 语言的简洁,高效和接近汇编语言等特点
      并对 C 语言的功能做了不少扩充
      用 C++ 编写的程序比 C 语言更安全,可读性更好,代码结构更为合理
    3.用 C++ 编写的程序质量高
      从开发时间,费用到形成的软件的可重用性,可扩充性,可维护性和可靠性等方面都有了很大的提高
    4.增加了面向对象的机制

>> 与 <<
  运算符 >> 在 C++ 中仍然保持 C 语言的"右移"功能
  但用于输入时扩充了其功能,表示将标准输入流对象 cin(通常指键盘) 读取的数值传送给右侧指定的变量
  >> 允许用户输入一连串数据
    cin >> a >> b >> c;
  数据之间用空白符(空格,回车, Tab 键)分隔
  1.默认情况下,运算符 >> 将跳过空白符,读入后面的与其变量类型相对应的值
    当输入字符串时,提取运算符 >> 的作用是跳过空白
    读入非空白字符,直到遇到另一个空白字符为止,并在串尾添加一个字符串结束符'\0'
      char *str;
      cin >> str;
      输入:abc def
      输出:abc
  2.系统除检查是否有空白外,还检查输入数据与变量的匹配情况
      int i;
      float x;
      cin >> i >> x;
      输入:56.79 45.6
      输出:56 0.79
    系统根据变量的类型来分隔输入的数据
    在上述情况下,系统把 56.79 中的小数点前的整数部分赋值给整型变量 i
    而把剩下的 0.79 赋值给浮点型变量 x

cin 与 cout
  使用 cin 和 cout 进行 I/O 操作时,在程序中必须嵌入头文件 iostream
  在 C++ 中我们仍然可以沿用传统的 stdio 函数库中的 I/O 函数,如 scanf 和 printf 等等其它的 C 输入输出函数
  在使用 cin 和 cout 输入输出数据时,会使用系统默认的格式
  我们也可以对输入输出的格式进行控制
    1.stew(n)
      控制输出数据的宽度
      需要添加头文件 iomanip

程序的编辑,编译,连接和运行
  Windows 平台下有 Visual C++ 和 C++ Builder
  Linux 平台下有 gcc 和 gdb

带默认参数的函数
  C 是没有此功能的

函数重载
  在同一作用域内,两个或两个以上的函数共用一个函数名
  被重载的函数称为重载函数
  系统根据实参的个数和类型决定使用哪个函数
  注意:
    1.函数返回值不在参数匹配检查之中
        int add(int a, int b){...};
        double add(int a, int b){...};
    2.函数重载与带默认参数的函数同时使用时,会引起二义性
        int add(int a=0, int b=0){...};
        int add(int a){...};
        add(5);
    3.在函数调用时,如果给出的实参和形参类型不相符
      C++ 编译器会自动执行类型转换工作
      如果转换成功,则程序继续执行,在这种情况下,有可能产生不可识别的错误
        int add(int a, int b){...};
        long add(long a, long b){...};
        add(1.1, 2.2);
      两个函数都满足条件,编译时会报错

::
  作用域运算符
  通常情况下,如果有两个同名变量,一个是全局的,另一个是局部的
  那么局部变量在其作用域下具有较高的优先权,他将屏蔽全局变量
  如果想在局部变量的作用于下使用同名的全局变量
  可在变量前加上 ::

new 和 delete
  C 语言使用函数 malloc 和 free 动态分配内存和释放动态分配的内存
  C++ 使用运算符 new 和 delete 能更好且简单地进行内存的分配和释放
  new 的基本形式:
    指针变量名 = new 类型;
    int *p;
    p = new int;
  delete 的基本形式:
    delete 指针变量名;
    delete p;
  虽然 new 和 delete 完成的功能类似于函数 malloc 和 free
  但它们有以下几个有点:
    1.new 可以根据数据类型自动计算所需要分配内存的大小
      而使用 malloc 函数时必须使用 sizeof 函数计算所需要的字节数,这就减少了发生错误的可能性
    2.new 能够自动返回正确的指针类型,而 malloc 函数的返回值类型一律为 void*
      必须在程序中进行强制类型转换,才能使其指针指向具体的数据
  1.使用 new 为数组动态分配内存空间
    必须提供所有维的大小
      int *pi = new int[10];
      int *pii = new int[2][2];
    无论几维数组,都只需要一对方括号
      delete []指针变量名;
      delete []pi;
      delete []pii;
  2.new 可为简单变量分配内存的同时进行初始化
    指针变量名 = new 类型(初值);
    int *p = new int(1);
  3.使用 new 动态分配内存时,若没有足够的内存满足分配要求
    则动态分配空间失败,部分编译系统将返回空指针 NULL
    因此可以对内存的动态分配是否成功进行检查
      if(!p){
        cout << "allocation failure.\n";
        return 1;
      }
    内存动态分配成功后不宜变动指针的值,否则在释放存储空间时会引起系统内存管理失败
  4.用 new 分配的存储空间不会自动释放,只能通过 delete 释放,
    因此要适时释放动态分配的存储空间

引用
  & 引用声明符
  它是对 C 的一个重要扩充
  变量的"引用"即为变量的别名
    类型 & 引用名 = 已定义的变量名;
    int i = 1;
    int &j = i;
  1.引用不是一种独立的数据类型,在声明引用时必须立即进行初始化
      int i = 1;
      int &j;
      j = i; // 错误,不能声明完成后再赋值
      double &k = i; // 错误,类型不一致
  2.可以为引用再引用
      int i = 1;
      int &j = i;
      int &k = j;
  3.指针是通过地址间接访问变量
    而引用是通过别名直接访问变量
  4.引用在初始化后不可以再被重新声明为另一个变量的引用
      int i,k;
      int &j = i;
      j = &k;
  引用作为函数参数
    1.C++ 提供引用,其主要一个用途时将引用作为函数的参数
      即"传值调用",这种传递是单向的,在执行函数期间形参值发生的变化并不会传回给实参
    2.指针变量作为函数参数
      这时实参传给形参的是实参变量的地址
      即"传址调用",这种传递是双向的,在执行函数期间形参值发生的变化会传回给实参
        void swap(int *a, int *b){...}
        int main(){
          swap(&m, &n);
        }
        m 和 n 的数据会互换
    3.把变量的引用作为函数形参
      即"传址调用"
        void swap(int &a, int &b){...}
        int main(){
          swap(m, n);
        }
        m 和 n 的数据会互换
  注意:
    1.不能建立引用的数组
        int a[4]="asd";
        int &arr[4] = a;
      企图建立一个包含4个元素的引用的数组,错误做法
      数组名 a 只代表数组首元素的地址,本身并不是一个占有存储空间的变量
    2.不能建立引用的引用,不能建立指向引用的指针
        int a = 1;
        int && b = a;
        int &*p = a;
      引用本身不是数据类型,所以没有引用的引用,也没有引用的指针
    3.可以将引用的地址赋值给指针,此时指针指向原来的变量
        int a = 1;
        int &b = a;
        iny *p = &b;
    4.可以用 const 对引用加以限定,不允许改变该引用的值
        int a = 5;
        const int &b = a;
        b = 3; // 错误,不可改变
      有时希望函数中保护形参的值不被改变可用此方法
        // 通过函数 i_Max 求出整型数组 a[200] 中的最大值
        int i_Max(const int* ptr); // 这样做的目的是确保形参数组的数据不被破坏(只读不可写)
        i_Max(a);

类和对象
  1.从结构到类
    C 语言的结构体有一个缺点
    一旦建立了一个结构体变量就可以在结构体外直接访问数据
    但现实中有些数据是不可以随便访问的,这样做是不安全的
    C 语言的结构体无法对数据进行保护和权限控制
    结构体中的数据和对数据进行的操作是分离的,没有把两者作为一个整体进行封装
    因此使程序的复杂性很难控制,维护数据要花费精力,所以影响生产效率
    于是 C++ 引入类的概念
    类将数据和相关函数封装成整体,具有良好的外部接口
    防止数据未经授权被访问,提供了模块间的独立性
    类声明的一般格式:
      class 类名{
        public:
          公有数据成员;
          公有成员函数;
        private:
          私有数据成员;
          私有成员函数;
      };
    关键字
      1.public
      2.private
      3.protected
        保护成员,可由本类的成员函数访问,也可以由本类的派生类的成员函数访问
        类外的任何访问都是违法的
    C++ 默认情况下类中的成员都是私有的
    结构体中的成员都是公有的
  2.成员函数的定义
    成员函数在类外定义的一般形式:
      返回值类型 类名::成员函数名(参数表){
        函数体
      }
      class Date{
        public:
          void setDate(int y, int m, int d); // 函数原型
          void showDate();
        private:
          int year;
          int month;
          int day;
      };
      void Date::setDate(){
        year = y;
        month = m;
        day = d;
      }
      void Date::showDate(){
        cout << year << "." << month << "." << day << endl;
      }
    在类声明中,成员函数原型的参数表中可以不说明参数名字而只用说明它们的类型
      void setDate(int , int , int);
    采用"在类声明中只给出成员函数的原型,而将成员函数的定义放在类的外部"的定义方式是 C++ 程序设计良好习惯
    这种方式不仅可以减少类体的长度,使类的声明简洁明了,便于阅读
    而且有助于把类的接口和类的实现细节相分离,隐藏了执行的细节
  3.内联成员函数的定义
    a.隐式声明
      将成员函数直接定义在类的内部,此时函数就是隐含的内联成员函数
      内联函数的调用类似宏指令的扩展,它直接在调用处扩展其代码,而不进行一般函数的调用操作
      这种定义内联成员函数的方法没有使用关键字 inline 进行声明,因此此方法称为隐式定义
        class Date{
          public:
            void setDate(int y, int m, int d){ // 直接定义在类的内部
              year = y;
              month = m;
              day = d;
            }
            void Date::showDate(){ // 直接定义在类的内部
              cout << year << "." << month << "." << day << endl;
            }
          private:
            int year;
            int month;
            int day;
        };
    b.显式声明
      在类中只给出成员函数的原型,而将成员函数的定义放在类的外部
      但需要在(类内函数原型声明前和)类外定义成员函数前需要冠以关键字 inline
      以此显式地说明这是一个内联函数,此方法称为显式定义
        class Date{
          public:
            inline void setDate(int y, int m, int d); // 函数原型声明前也可不加 inline
            inline void showDate();
          private:
            int year;
            int month;
            int day;
        };
        inline void Date::setDate(int y, int m, int d){
          year = y;
          month = m;
          day = d;
        }
        inline void Date::showDate(){
          cout << year << "." << month << "." << day << endl;
        }
      使用 inline 定义内联函数时
      必须将类的声明和内联成员函数的定义都放在同一文件(或同一个头文件)中
      否则编译时无法进行代码置换

对象的定义和使用
  C++ 把类的变量称为类的对象
  对象也称为类的实例
  对象的定义:
    1.声明类的同时直接定义了对象
      class Date{
        ...
      }date1,date2,*p;
      p = &date1;
    2.声明类之后再定义对象
      Date date3,date4;
  对象中成员的访问:
    1.通过对象名和对象选择符访问对象中的成员
        date1.setDate(2021,1,22);
        date1.showDate();
      "."称为对象选择符,简称点运算符
    2.通过指向对象的指针访问对象中的成员
        date1.year;
        (*p).year;
        p->year;
    3.通过对象的引用访问对象中的成员
      为对象定义一个引用(为对象起别名)
      对象与引用占有相同的存储单元
        Date &d1 = date1;
        d1.year;

构造函数
  构造函数是一种特殊的成员函数
  它主要用于为对象分配空间进行初始化
  构造函数的名字必须与类名相同
  可以有任意类型的参数
  没有任何返回类型,不返回任何值
  不需要用户调用,而是在建立对象时自动执行的
  构造函数的功能是由用户定义的,用户根据对象初始化的要求设计函数体和函数参数
    class Date{
      public:
        Date(int y, int m, int d); // 构造函数原型声明
        void showDate();
      private:
        int year;
        int month;
        int day;
    };
    Date::Date(int y, int m, int d){
      year = y;
      month = m;
      day = d;
    }
    void Date::showDate(){
      cout << year << "." << month << "." << day << endl;
    }
  构造函数的主要功能是给对象分配空间,进行初始化

用成员初始化表对数据成员初始化
  C++ 还提供了另一种初始化数据成员的方法
  用成员初始化来表现对数据成员的初始化
  在函数首部实现对数据成员的初始化
    Date::Date(int y, int m, int d):year(y), month(m), day(d){}
  建议使用此方法
        
析构函数
  一种特殊的成员函数
  它执行与构造函数相反的操作
  通常用于撤销对象时的清理任务,如释放分配给对象的内存空间等
  特点:
    1.析构函数与构造函数名字相同,但需要在前加一个波浪符号 ~
    2.析构函数没有参数和返回值,不能重载
    3.当撤销对象时,编译系统会自动地调用析构函数
  class Date{
    public:
    ~Date();
    ...
  };
  ~Date::Date(){}
  ...

默认的构造函数和默认的析构函数
  如果没有给类定义构造函数
  系统会自动生成一个默认的无参构造函数和一个无参析构函数
  如果有定义则系统不会这样做

构造函数的重载
  一个类可定义多个构造函数,即重载
  注意不要忘了函数原型声明

拷贝构造函数
  一种特殊的构造函数,其形参是本类对象的引用
  其作用是在建立一个新对象时,使用一个已经存在的对象去初始化这个对象
  特点:
    1.本质为构造函数,所以函数名与类名相同,且没有返回值
    2.拷贝函数只有一个参数,并且是同类对象的引用
    3.每个类必须有一个拷贝构造函数,也可以自己定义
      如果没有定义则系统会自动产生一个默认的拷贝构造函数
    class Date{
      public:
      Date(const Date& d){
        year = d.year++;
        month = d.month++;
        day = d.day++;
      }
      ...
    };
    int main(){
      Date date1;
      ... // 初始化 date1
      Date date2(date1); // 拷贝,也称代入法
      Date date3 = date1; // 赋值法
    }
  赋值法实际调用的也是拷贝构造函数
  调用拷贝函数的3种情况
    1.用类的对象去初始化该类的另一个对象时
    2.当函数的形参是类的对象时
    3.当函数的返回值是对象时
      当函数调用 return xxx; 时将会调用拷贝函数
      将 xxx 的值拷贝到一个无名对象中,这个无名对象是编译系统在主程序中临时创建的
      函数运行结束时对象 xxx 消失,但临时对象会保存至调用该函数处的变量中(class xx = fun();)
      执行完该语句后,临时无名对象的使命也就完成了,该临时对象便自动消失了

自引用指针
  C++ 为成员函数提供了一个名为 this 的指针,即称为自引用指针
  每当创建一个对象时,系统就把 this 指针初始化为指向该对象
  即 this 指针的值是当前调用成员函数的对象的起始地址
  每当调用成员函数时,系统就自动把 this 指针作为一个隐含的参数传递给该函数

string 类
  强调一下,它是一个类!
  C++ 支持两种类型的字符串
  第一种是 C 语言中介绍过的包含一个结束符"\0"(即以 NULL 结束)的字符数组
  标准库函数提供了一组对其进行操作的函数,可完成许多常用的字符操作
  例如 strcpy strcat strlen 等等
  但数据与处理数据的函数分离不符合面向对象方法的要求
  为此,在 C++ 的标准库中声明了另一种更方便的字符串类型,即字符串类 string
  使用 string 类必须在程序的开始包括头文件 string
    #include<string>
  常用的 string 类运算符
    运算符   注释
    =        赋值
    +        将两个字符串连接成一个新字符串
    +=       <略>
    ==       判断两字符串是否相等
    !=       <略>
    <        <略>
    <=       <略>
    >=       <略>
    []       s[1]; 访问字符串下标为1的字符
    >>       cin>>s; 从键盘输入一个字符串给 s
    <<       cout<<s; 将字符串 s 输出
  
对象数组
  指每一个数组元素都是对象的数组
    class Exam{
      public:
      Exam(){
        x = 100;
      }
      Exam(int n){
        x = n;
      }
      int get_x(){
        return x;
      }
      private:
        int x;
    };
    int main(){
      Exam arr[5] = {1, 2, 3, 4} // 用只有一个参数的构造函数给对象数组赋值,最后一个使用无参构造函数初始化
      for(int i=0;i<4;i++){
        cout << arr[i].get_x() << endl;
      }
    }

对象指针
  每个对象在初始化后都会在内存中占有一定的空间
  因此,既可以通过对象名访问
  也可以通过对象地址访问
    Exam e1,e2[2],*p;
    p = &e1;
    p->get_x();
    p = &e2;
    p++;
    p->get_x(); // 访问 e2[1]

使用对象作为函数参数
  <略>

使用对象指针作为函数参数
  <略>

使用对象引用作为函数参数
  在实际应用中,大部分程序员喜欢用对象引用取代对象指针作为函数参数
    
静态数据成员
  有时希望某个或几个数据成员为所有的对象共有,实现一个类的多个对象之间的数据共享
  于是 C++ 提出了静态成员的概念
    static 数据类型 数据成员名;
    class xxx{
      public:
      static int i;
      ...
    };
    int main(){
      xxx::i = 100; // 公共静态数据成员可在对象定义前被访问
    }
  注意:
    1.静态数据成员属于类(准确地说是属于类中对象的集合),它不属于某一个对象
      因此可以使用"类名::"访问静态的数据成员
        类名::静态数据成员名
    2.静态数据成员与静态变量一样,是在编译时创建并初始化的,它在任何对象被建立之前就存在
        对象名.静态数据成员名;
        对象指针->静态数据成员名;
    3.在类外,私有静态数据成员不能直接访问,必须通过公有的成员函数访问
    6.C++ 支持静态数据成员的一个主要原因是可以不必使用全局变量
      依赖全局变量的类几乎都是违反面向对象程序设计的封装特性的
    7.与普通数据成员不同,静态数据成员不可以在定义时进行赋值,应该在类外单独进行

静态成员函数
  静态成员函数属于整个类,是该类所有对象共享的成员函数
  它的作用是为了处理静态数据成员
    static 返回类型 静态成员函数名(参数表);
  调用公有静态成员函数的一般格式:
    类名::静态成员函数名(实参表);
    对象.静态成员函数名(实参表);
    对象指针->静态成员函数名(实参表);
  一般而言,静态成员函数不访问类中的非静态成员
  若有需要,静态成员函数只能通过对象名(或指针,对象引用)访问该对象的非静态成员

友元
  类的主要特点之一是数据隐藏和封装
  但是,有时为了访问类的私有成员而需要在程序中多次调用成员函数
  频繁调用带来较大的时间和空间开销,从而降低程序的运行效率
  为此 C++ 提供了一种访问私有成员的途径
  在不放弃私有成员数据安全性的情况下
  使得一个普通函数或类的成员函数可以访问到封装于某一类中的信息(包括公有,私有,保护成员)
  在 C++ 中用友元作为实现这个要求的辅助手段
  C++ 中的友元为数据隐藏这堵墙开了一个孔
  外界可以通过这个孔窥视类内部的秘密
  友元是一扇通向私有成员的后门

友元函数
  友元函数既可以是不属于任何类的非成员函数,也可以是另一个类的成员函数
  友元函数不是当前类的成员函数,但它可以访问该类所有的成员
  包括私有成员,保护成员和公有成员
  在类中声明友元函数时需要在其函数名前加关键字 friend
  友元函数既可定义在类内部,也可定义在类的外部
  将非成员函数声明为友元函数
    注意:
      1.友元函数不是类的成员,外部定义时不需要加"类名::",所以不能使用 this
      2.引入友元提高了程序运行效率,实现了类之间的数据共享,也方便编程
        但声明友元函数相当于在实现封装的黑盒子上开洞
        这将破坏数据的隐蔽性和类的封装性,降低了程序的可维护性
        这与面向对象的程序设计思想是背道而驰的,慎用友元函数
  将成员函数声明为友元函数
    一个类的成员函数也可以作为另一个类的友元函数
    它是友元函数的一种,称为友元成员函数
    友元成员函数既可以访问自己所在类对象中的私有成员和公有成员
    也可以访问 friend 声明语句所在类对象中的所有成员
    这样能使两个类相互合作,协调工作,完成某一项任务

友元类
  将一个类 A 声明为另一个类 B 的友元
  这时类 A 为类 B 的友元类
  类 B 的所有成员函数都成为类 B 的友元函数
  类 B 中的所有成员函数都可以访问类 A 中的所有成员
    friend 类名;
  注意:
    1.友元关系是单向的,不具有交换性
      若声明了类 X 是类 Y 的友元(即在类 Y 定义中声明类 X 为 friend 类)
      不等于类 Y 一定是 X 的友元,这要看类 X 中是否具有相应的声明
    2.友元关系不具有传递性
      若类 X 是类 Y 的友元,类 Y 是类 Z 的友元
      不一定类 X 是类 Z 的友元
      如果想让类 X 是类 Z 的友元类,应在类 Z 中作出声明

类的组合
  在一个类中内嵌另一个类的对象作为数据成员,称为类的组合
  该内嵌对象称为对象成员,也称为子对象
    class Y{ ... };
    class X{
      Y y;
      ...
    };
  在创建对象时既要本类的基本数据成员初始化,又要对内嵌的对象成员进行初始化
    class X{
      类名1 对象成员名1;
      ...
      类名i 对象成员名i;
    };
  一般定义:
    X::X(形参列表0):(对象成员名1)(形参表1),...,对象成员名i(形参表i){
      // 类 X 的构造函数体
    }
  形参表i给出了初始化对象成员所需要的数据,它们一般来自形参表0

共享数据的保护
  虽然 C++ 采取了不少措施(如设置 private 数据等)来增加数据的安全性
  但是有些数据是共享的,人们可以在不同场合通过不同的途径访问同一个数据对象
  程序中各种形式的数据共享在不同程度上破坏了数据的安全性
  常类型的引入就是为了既保证数据共享又防止数据被改动
  常类型是指使用类型修饰符 const 说明的类型
  常类型的变量或对象成员的值在程序运行期间是不可改变的

常对象
  用 const 修饰的对象被称为常对象
  常对象中的数据成员为常量且必须要有初值
  常对象在整个生存期内不能被改变
  一般形式:
    类名 const 对象名[(参数表)];
    const 类名 对象名[(参数表)];
  在定义时必须进行初始化且不能被更新
  另外,常对象只能调用常成员函数

常对象成员
  C++ 可以声明类时将其中的成员声明为 const
  即声明为常数据成员和常成员函数
  常数据成员
    const 类型 变量名;
  常成员函数
    类型 函数名(参数表) const;

多文件程序
  从众多的完整 c++ 源程序实例中分析得出
  基本都是由3部分构成
    类的声明部分
    类的实现部分
    类的使用部分
  在实际程序设计中,一个源程序按照结构可以划分为3个文件
    类声明文件(*.h)
    类实现文件(*.cpp)
    类的使用文件(*.cpp,主函数文件)
  将类的声明部分放在类声明文件(头文件)中,类中向用户提供成员函数所需的函数原型,这就形成了类的 public 外部接口
  将类成员函数的定义放在类实现文件中,这就形成了类的实现方法
  将类的使用部分(通常是主程序)放在类使用文件中,这样可以清晰地表示出本程序所要完成的工作
  把类的声明和实现放在两个不同的文件中主要有以下考虑:
    1.类的实现文件通常较大,将两者混合在一起不便阅读,管理和维护
    2.将类的成员函数的实现放在其声明文件中与放在实现文件中在编译时的含义是不一样的
      若将成员函数的实现直接放在类的声明中,则类的成员函数将作为内联函数处理
      显然这是不合适的
    3.对于软件开发商来说,他们可以向用户提供一些程序模块这些程序模块往往只向用户公开类的声明(即接口)而不是源码
      类的用户使用类时不需要访问类的源代码,但需要连接类的目标码
      类的声明和实现分开管理可以很好地解决这个问题
    4.便于团体式的大型软件开发

继承
  继承即从先辈处得到属性和行为特征

派生
  从已有类(基类或父类)产生新类(子类或派生类)的过程即为类的派生
  一般声明格式:
    class 派生类名:[继承方式] 基类名{
      派生类新增的数据成员和成员函数
    }
  继承方式:
    1.公有继承
    2.私有继承
    3.保护继承
  如果不显式地给出继承方式关键字,系统默认为私有继承

基类成员在派生类中的访问属性
  基类中的成员   继承方式   基类成员在派生类中的访问属性
  private       private    不可直接访问
  protected     private    private
  public        private    private

  private       protected  不可直接访问
  protected     protected  protected
  public        protected  protected

  private       public     不可直接访问
  protected     public     protected
  public        public     public

派生类对基类成员的访问规则
  1.私有继承的访问规则
    基类中的成员   私有成员   保护成员   公有成员
    内部访问       不可访问   可访问     可访问
    对象访问       不可访问   不可访问   不可访问
  2.保护继承的访问规则
    基类中的成员   私有成员   保护成员   公有成员
    内部访问       不可访问   可访问     可访问
    对象访问       不可访问   不可访问   不可访问
  3.公有继承的访问规则
    基类中的成员   私有成员   保护成员   公有成员
    内部访问       不可访问   可访问     可访问
    对象访问       不可访问   不可访问   可访问

派生类构造函数和析构函数的调用顺序
  通常情况下,当创建派生类对象时
  首先调用基类的构造函数
  随后再调用派生类的构造函数
  当撤销派生类对象时,则先调用派生类的析构函数
  随后再调用基类的析构函数

派生类构造函数和析构函数的构造规则
  1.简单的派生类的构造函数和析构函数
    当基类的构造函数没有参数或没有显式定义构造函数时
    派生类可以不向基类传递参数,甚至可以不定义构造函数
    派生类构造函数的一般格式:
      派生类名(参数总表):基类名(参数表){
        派生类新增数据成员的初始化语句
      }
    析构函数各自定义即可
  2.含有子对象的派生类的构造函数
    一般格式:
      派生类名(参数总表):基类名(参数表0),子对象名1(参数表1),...,子对象名n(参数表n){
        派生类新增成员的初始化语句
      }
    在定义派生类对象时,构造函数的调用顺序如下:
      1.调用基类的构造函数,对基类数据成员初始化
      2.调用子类对象的构造函数,对子对象的数据成员初始化
      3.调用派生类的构造函数体,对派生类数据成员初始化
      4.撤销对象时,析构函数的调用顺序与构造函数的调用顺序正好相反
        首先调用派生类的析构函数,然后调用子对象的析构函数,最后调用基类的析构函数
    注意:
      1.当基类构造函数不带参数时,派生类不一定需要定义构造函数
      2.若基类使用默认构造函数或不带参数的构造函数,则在派生类中定义构造函数时可略去":基类名(参数表)"
        此时若派生类也不需要构造函数则可不定义构造函数
      3.如果派生类的基类也是一个派生类,每个派生类只需负责其直接基类或基类数据成员的初始化,依次上溯

在派生类中显示访问基类成员
  C++ 允许派生类重新说明与基类成员同名的成员,称派生类成员覆盖基类的同名成员
  一般形式:
    基类名::成员名
    或
    基类名::成员函数(参数表);

多重继承
  当一个派生类具有多个基类时,这种派生方法称为多基派生或多重继承
  假设已声明类 X 和 Y ,可声明多重继承的派生类 Z
    class Z:public X,private Y{
      派生类 Z 中新增的数据成员和成员函数;
    };
  声明多重继承派生类的一般形式:
    class 派生类名:继承方式1 基类名1, ... , 继承方式i 基类名i, ... , 继承方式n 基类名n{
      派生类新增的数据成员和成员函数
    };

多重继承派生类的构造函数与析构函数
  其与单继承时的构造函数定义形式相似,只是在初始表中包含多个基类构造函数,它们之间用","分隔
  一般形式:
    派生类名(参数总表):基类名1(参数表1), ... ,基类名i(参数表i),...,基类名n(参数表n){
      派生类新增成员的初始化语句
    }
  *执行 12 观察析构函数执行顺序!

虚基类
  如果一个类有多个基类
  而这些直接基类又有一个共同的基类
  则在最底层的派生类中会保留这个间接的共同基类数据成员的多份同名成员
  在派生类中访问这些同名的成员时必须加上"基类名::"
  使其唯一地标识是哪一个基类的成员,以免产生二义性
  声明虚基类的语法形式:
    class 派生类名:virtual 继承方式 类名{
      ...
    }
  *通俗概括
      Base3
      ^   ^
  Base1   Base2
     ^     ^
      Base(A)
   不声明虚基类: Base1 和 Base2 除了包含 Base 中的 a 之外还会各自另保存一个 a 数据成员
               即 Base1 和 Base2 各自都有2个 a 且互不影响,那么对于 Base3 来说就共有3个同名为 a 的数据成员
   声明虚基类: Base1 和 Base2 共用 Base 中 a 数据成员,只有一个名为 a 的数据成员

虚基类的初始化
  在使用虚基类机制时应该注意以下几点:
    1.如果在虚基类中定义有带形参的构造函数,并且没有定义默认形式的构造函数
      则在整个继承结构中,所有直接或间接的派生类都必须在构造函数的成员初始化表中列出对虚基类构造函数的调用
      以初始化在虚基类中定义的数据成员
    2.建立一个对象时,如果这个对象中含有从虚基类继承来的成员
      则虚基类的成员是由最远派生类的构造函数通过调用虚基类的构造函数进行初始化的
      该派生类的其它基类对虚基类构造函数的调用都自动被忽略
    3.若同一层次中同时包含虚基类和非虚基类
      应先调用虚基类的构造函数,再调用非虚基类的构造函数
    4.对于多个虚基类,构造函数的执行顺序仍然是先左后右,自上而下
    5.对于非虚基类,构造函数的执行顺序仍是先左后右,自上而下
    6.若虚基类由非虚基类派生而来,则仍然先调用基类构造函数,再调用派生类的构造函数 

多态
  1