前言
  它是对 C 语言的扩充
  主要是引进面向对象机制
  最初的 C++ 被称为"带类的C",1983年正式取名为 C++
  特点:
    1.C++ 是 C 的超集
      C++ 保持与 C 语言的兼容,这使得许多 C 代码不经修改就可以为 C++ 所用
    2.C++ 保持了 C 语言的简洁,高效和接近汇编语言等特点
      并对 C 语言的功能做了不少扩充
      用 C++ 编写的程序比 C 语言更安全,可读性更好,代码结构更为合理
    3.用 C++ 编写的程序质量高
      从开发时间,费用到形成的软件的可重用性,可扩充性,可维护性和可靠性等方面都有了很大的提高
    4.增加了面向对象的机制

>> 与 <<
  运算符 >> 在 C++ 中仍然保持 C 语言的"右移"功能
  但用于输入时扩充了其功能,表示将标准输入流对象 cin(通常指键盘) 读取的数值传送给右侧指定的变量
  >> 允许用户输入一连串数据
    cin >> a >> b >> c;
  数据之间用空白符(空格,回车, Tab 键)分隔
  1.默认情况下,运算符 >> 将跳过空白符,读入后面的与其变量类型相对应的值
    当输入字符串时,提取运算符 >> 的作用是跳过空白
    读入非空白字符,直到遇到另一个空白字符为止,并在串尾添加一个字符串结束符'\0'
      char *str;
      cin >> str;
      输入:abc def
      输出:abc
  2.系统除检查是否有空白外,还检查输入数据与变量的匹配情况
      int i;
      float x;
      cin >> i >> x;
      输入:56.79 45.6
      输出:56 0.79
    系统根据变量的类型来分隔输入的数据
    在上述情况下,系统把 56.79 中的小数点前的整数部分赋值给整型变量 i
    而把剩下的 0.79 赋值给浮点型变量 x

cin 与 cout
  使用 cin 和 cout 进行 I/O 操作时,在程序中必须嵌入头文件 iostream
  在 C++ 中我们仍然可以沿用传统的 stdio 函数库中的 I/O 函数,如 scanf 和 printf 等等其它的 C 输入输出函数
  在使用 cin 和 cout 输入输出数据时,会使用系统默认的格式
  我们也可以对输入输出的格式进行控制
    1.stew(n)
      控制输出数据的宽度
      需要添加头文件 iomanip

程序的编辑,编译,连接和运行
  Windows 平台下有 Visual C++ 和 C++ Builder
  Linux 平台下有 gcc 和 gdb

带默认参数的函数
  C 是没有此功能的

函数重载
  在同一作用域内,两个或两个以上的函数共用一个函数名
  被重载的函数称为重载函数
  系统根据实参的个数和类型决定使用哪个函数
  注意:
    1.函数返回值不在参数匹配检查之中
        int add(int a, int b){...};
        double add(int a, int b){...};
    2.函数重载与带默认参数的函数同时使用时,会引起二义性
        int add(int a=0, int b=0){...};
        int add(int a){...};
        add(5);
    3.在函数调用时,如果给出的实参和形参类型不相符
      C++ 编译器会自动执行类型转换工作
      如果转换成功,则程序继续执行,在这种情况下,有可能产生不可识别的错误
        int add(int a, int b){...};
        long add(long a, long b){...};
        add(1.1, 2.2);
      两个函数都满足条件,编译时会报错

::
  作用域运算符
  通常情况下,如果有两个同名变量,一个是全局的,另一个是局部的
  那么局部变量在其作用域下具有较高的优先权,他将屏蔽全局变量
  如果想在局部变量的作用于下使用同名的全局变量
  可在变量前加上 ::

new 和 delete
  C 语言使用函数 malloc 和 free 动态分配内存和释放动态分配的内存
  C++ 使用运算符 new 和 delete 能更好且简单地进行内存的分配和释放
  new 的基本形式:
    指针变量名 = new 类型;
    int *p;
    p = new int;
  delete 的基本形式:
    delete 指针变量名;
    delete p;
  虽然 new 和 delete 完成的功能类似于函数 malloc 和 free
  但它们有以下几个有点:
    1.new 可以根据数据类型自动计算所需要分配内存的大小
      而使用 malloc 函数时必须使用 sizeof 函数计算所需要的字节数,这就减少了发生错误的可能性
    2.new 能够自动返回正确的指针类型,而 malloc 函数的返回值类型一律为 void*
      必须在程序中进行强制类型转换,才能使其指针指向具体的数据
  1.使用 new 为数组动态分配内存空间
    必须提供所有维的大小
      int *pi = new int[10];
      int *pii = new int[2][2];
    无论几维数组,都只需要一对方括号
      delete []指针变量名;
      delete []pi;
      delete []pii;
  2.new 可为简单变量分配内存的同时进行初始化
    指针变量名 = new 类型(初值);
    int *p = new int(1);
  3.使用 new 动态分配内存时,若没有足够的内存满足分配要求
    则动态分配空间失败,部分编译系统将返回空指针 NULL
    因此可以对内存的动态分配是否成功进行检查
      if(!p){
        cout << "allocation failure.\n";
        return 1;
      }
    内存动态分配成功后不宜变动指针的值,否则在释放存储空间时会引起系统内存管理失败
  4.用 new 分配的存储空间不会自动释放,只能通过 delete 释放,
    因此要适时释放动态分配的存储空间

引用
  & 引用声明符
  它是对 C 的一个重要扩充
  变量的"引用"即为变量的别名
    类型 & 引用名 = 已定义的变量名;
    int i = 1;
    int &j = i;
  1.引用不是一种独立的数据类型,在声明引用时必须立即进行初始化
      int i = 1;
      int &j;
      j = i; // 错误,不能声明完成后再赋值
      double &k = i; // 错误,类型不一致
  2.可以为引用再引用
      int i = 1;
      int &j = i;
      int &k = j;
  3.指针是通过地址间接访问变量
    而引用是通过别名直接访问变量
  4.引用在初始化后不可以再被重新声明为另一个变量的引用
      int i,k;
      int &j = i;
      j = &k;
  引用作为函数参数
    1.C++ 提供引用,其主要一个用途时将引用作为函数的参数
      即"传值调用",这种传递是单向的,在执行函数期间形参值发生的变化并不会传回给实参
    2.指针变量作为函数参数
      这时实参传给形参的是实参变量的地址
      即"传址调用",这种传递是双向的,在执行函数期间形参值发生的变化会传回给实参
        void swap(int *a, int *b){...}
        int main(){
          swap(&m, &n);
        }
        m 和 n 的数据会互换
    3.把变量的引用作为函数形参
      即"传址调用"
        void swap(int &a, int &b){...}
        int main(){
          swap(m, n);
        }
        m 和 n 的数据会互换
  注意:
    1.不能建立引用的数组
        int a[4]="asd";
        int &arr[4] = a;
      企图建立一个包含4个元素的引用的数组,错误做法
      数组名 a 只代表数组首元素的地址,本身并不是一个占有存储空间的变量
    2.不能建立引用的引用,不能建立指向引用的指针
        int a = 1;
        int && b = a;
        int &*p = a;
      引用本身不是数据类型,所以没有引用的引用,也没有引用的指针
    3.可以将引用的地址赋值给指针,此时指针指向原来的变量
        int a = 1;
        int &b = a;
        iny *p = &b;
    4.可以用 const 对引用加以限定,不允许改变该引用的值
        int a = 5;
        const int &b = a;
        b = 3; // 错误,不可改变
      有时希望函数中保护形参的值不被改变可用此方法
        // 通过函数 i_Max 求出整型数组 a[200] 中的最大值
        int i_Max(const int* ptr); // 这样做的目的是确保形参数组的数据不被破坏(只读不可写)
        i_Max(a);