#include <stdio.h>
#include "0-link.h"
int main()
{
    printf("---hi---\n");

    char str_1[100] = "qwe123!@#打土豪"; // char
    printf(str_1);
    printf("\nstr_1.size=%d\n", sizeof(str_1));
    printf("str_1=%s\n", str_1);

    printf("result=%d\n", result());

    putchar('q'); // 打印单个字符
    return 0;
}
/**
 * C/C++ 编译过程详解
 *   源代码(.c .cpp) ---|
 *      |               |
 *   编译器             |
 *      |               |
 *    预编译(.i)        |
 *      |               |---编译过程
 *   汇编代码(.s)       |
 *      |               |
 *   汇编器             |
 *      |               |
 *   目标代码(.o)-------|
 *      |
 *      |     其它目标代码     库文件
 *      |          |            |
 *      |----------|------------|
 *               连接器
 *                 |
 *             可执行程序
 * 
 * 词法与语法
 *   词法
 *     源代码由字符流组成,字符流包括关键字,变量名,函数名,括号等等符号
 *     比如变量名必须以下划线或字母开头,括号必须成对等等
 *   语法
 *     <略>
 * 
 * 编译器的工作过程
 *   编译过程可分为编译和汇编两个阶段
 *   编译
 *     编译是读取源程序(字符流),对之进行词法和语法的分析,将高级语言指令转换为功能等效的汇编代码
 *     源文件的编译过程包含如下两个主要阶段
 *     1.编译预处理
 *       读取 C 源程序,对其中的伪指令(以 # 开头的指令)和特殊符号进行处理并生成 .i 文件
 *       伪指令主要包括以下4各方面
 *         <1>宏定义指令
 *            如 # define Name TokenString , # undef 等
 *            对于 第一个伪指令,预编译所要做的是将程序中的所有 Name 用 TokenString 替换
 *            但作为字符串常量的 Name 则不被替换
 *            对于第二个伪指令,则将取消对某个宏的定义,使以后该串的出现不再被替换
 *         <2>条件编译指令
 *            如 # ifdef , # ifndef , # else , # elif , # endif 等
 *            这些伪指令的引入使得程序员可以通过定义不同的宏来决定编译程序对哪些代码进行处理
 *            预编译程序将根据有关的文件,将那些不必要的代码过滤掉
 *         <3>头文件包含指令
 *            如 # include"FileName" 等
 *            在头文件中一般用伪指令 # define 定义了大量的宏(最常见的是字符常量)
 *            同时包含有各种外部符号的声明
 *            采用头文件的目的主要是为了使某些定义可以供多个不同的 C 源程序使用
 *            因为在需要用到这些定义的 C 源程序中,只需加上一条 # include 语句即可
 *            预编译程序将把头文件中的定义统统都加入到它所产生的输出文件中
 *            以供编译程序对之进行处理
 *         <4>特殊符号
 *            如 LINE 标识被解释为当前行号(十进制数), FILE 则被解释为当前被编译的 C 源程序的名称
 *            预编译程序对于在源程序中出现的这些串将用合适的值进行替换
 *       预编译程序所完成的基本上都是对源程序的"替换"工作
 *       经过替换生成一个没有宏定义,条件编译指令,特殊符号的输出文件
 *       这个文件的含义同没有经过预处理的源文件是相同的,但内容有所不同
 *       下一步,此输出文件将作为编译程序的输入而被翻译成机器指令
 *     2.编译,优化阶段
 *       经过预处理得到的输出文件中,只有常量
 *       如数字,字符串,变量的定义,以及 C 语言的关键字,如 main , if , else , for , { , } , + , - , * , / 等等
 *       编译程序所要做的工作就是通过词法分析和语法分析,在确认所有的指令都符合语法规则之后
 *       将其翻译成等价的中间代码表示或汇编代码
 *       优化处理是编译系统中一项比较艰深的技术
 *       它涉及到的问题不仅同编译技术本身有关,而且同机器的硬件环境也有很大的关系
 *       优化一部分是对中间代码的优化,这种优化不依赖于具体的计算机
 *       主要的工作是删除公共表达式,循环优化(代码外提,强度削弱,变换循环控制条件,已知量的合并等),复写传播,以及无用赋值的删除等等
 *       另一种优化则主要针对目标代码的生成而进行的
 *       它同机器的硬件结构密切相关,最主要的是考虑如何充分利用机器的各个硬件寄存器存有关变量的值,以减少对于内存的访问次数
 *       另外,如何根据机器硬件执行指令的特点(如流水线 RISC CISC VLIW 等)而对指令进行一次调整使目标代码比较短,执行效率比较高,也是一个重要研究课题
 *       经过优化得到的汇编代码必须经过汇编程序的汇编转换成相应的机器指令,方可被机器执行
 *   汇编
 *     汇编过程实际上指把汇编语言代码翻译成目标机器指令的过程
 *     对于被翻译系统处理的每一个 C 语言源程序都将最终经过这一处理而得到相应的目标文件
 *     目标文件中所存放的也就是与源程序等效的目标的机器语言代码
 *     目标文件由段组成,通常一个目标文件中至少有两个段
 *       代码段:包含程序的指令,一般是可读可执行不可写的
 *       数据段:包含各种全局变量或静态变量的数据,一般可读可写可执行
 *     UNIX 环境下主要有三种类型的目标文件
 *       可重定位文件:包含适合于其它目标文件链接来创建一个可执行的或者共享的目标文件的代码和数据
 *       共享的目标文件:包含适合在两种上下文里链接的代码和数据
 *                     第一种是链接程序,可把它与其它可重定位文件及共享的目标文件一起处理来创建另一个目标文件
 *                     第二种是动态链接程序,将它与另一个可执行文件及其它的共享目标文件结合到一起,创建一个进程映像
 *       可执行文件:它包含了一个可以被操作系统创建一个进程来执行它的文件
 *     汇编程序生成的实际上是第一种类型的目标文件,对于后两种还需要其它的一些处理才能得到,这就是链接程序的工作了
 * 
 * 链接过程 
 *   主要链接方式:静态链接,动态链接
 *   两者主要区别在于链接的时机不一样
 *   静态链接是在形成可执行程序前,而动态链接则是在程序执行时
 *   静态链接
 *     由于多个源文件之间不是独立的,会存在多种依赖关系
 *     但每个源文件都是独立编译的(每个 .c 文件会形成一个对应的 .o 文件)
 *     为了满足文件之间的依赖关系,则需要将这些源文件产生的目标文件进行链接
 *     从而形成一个可以执行的程序,这个链接的过程就是静态链接
 *     原理
 *       由很多目标文件进行链接形成的是静态库,反之静态库也可以简单地看成是一组目标文件的集合
 *       即很多目标文件经过压缩后形成的一个文件
 *     缺点
 *       浪费空间
 *       因为每个可执行程序中对所有需要的目标文件都要有一份副本
 *       更新困难
 *       每当库函数的代码修改则需重新编译链接形成可执行程序
 *     优点
 *       运行速度快
 *       在可执行程序中已经具备了所有执行程序所需要的任何东西
 *   动态链接
 *     解决静态链接的缺点(与之互补)
 *     把程序按照模块拆分成各个相对独立部分,在程序运行时才将它们链接在一起形成一个完整的程序 
 *   据计算,动态链接与静态链接相比,性能损失在5%以下,经实践证明,性能损失是值得的
 * 
 *   2.词法与语法分析阶段
 *   3.编译
 *       将代码编译成纯汇编语句,再汇编成二进制代码,生成目标文件,即 .obj 文件
 *   4.连接
 *       将各个目标文件中的各段代码进行绝对地址定位
 *       生成与特定平台相关的可执行文件
 *       最后用 objcopy 生成纯二进制代码,即去掉了文件格式信息(生成 .exe 文件,在 PowerShell 中使用 ./ 执行)
 * 
 * #include <stdio.h>
 *   预处理器找到 stdio.h 文件
 *   将该文件内容替换掉该行语句
 *   全称 standardinputoutput.header
 *   即"标准输入输出头文件"
 *   该文件包含输入输出函数的声明,即可在程序中使用这些函数
 *   此外,把基本输入输出函数声明放在头文件里还与操作系统有关
 * 
 * .c 与 .h
 *   编译器在编译时是以 C 文件为单位进行的
 *   如果你的项目没有 C 文件则项目无法编译
 *   连接器是以目标文件为单位,它将一个或多个目标文件进行函数与变量的重定位生成最终的可执行文件
 *   在 PC 上的程序开发,一般都有 main 函数,这是各个编译器的约定
 *   两者虽然本质上无区别,但一般默认 .h 是头文件,内含函数声明,宏定义,结构体定义等
 *   .c 是程序文件,内含函数实现,变量定义等
 *   后缀仅与编译器的配置有关,只不过默认对 .c 和 .h 的等后缀文件进行默认的相关操作
 *   可修改编译器相关配置调整后缀与相关操作的对应关系
 * 
 * 静态链接
 *   
 * 
 **/